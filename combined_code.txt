

# --- build_exe.py ---
# SOLUCI√ìN 1: Script simplificado sin scipy problem√°tico
import os
import datetime
import sys
import PyInstaller.__main__

def build_simple():
    """Versi√≥n simplificada que evita el problema con scipy"""
    timestamp = datetime.datetime.now().strftime('%y-%m-%d_%H-%M-%S')
    exe_name = f'voider-{timestamp}'
    
    base_dir = os.path.dirname(os.path.abspath(__file__))
    build_root = os.path.join(base_dir, 'builds')
    dist_dir = os.path.join(build_root, 'dist')
    work_dir = os.path.join(build_root, 'build')
    spec_dir = build_root
    main_script = os.path.join(base_dir, 'voider.py')
    icon_path = os.path.join(base_dir, 'voider.ico')
    
    os.makedirs(dist_dir, exist_ok=True)
    os.makedirs(work_dir, exist_ok=True)
    os.makedirs(spec_dir, exist_ok=True)
    
    # Argumentos m√≠nimos - SIN scipy que est√° causando problemas
    args = [
        '--clean',
        '--onefile',  # Cambiar a onedir por ahora
        '--windowed',
        main_script,
        f'--name={exe_name}',
        f'--distpath={dist_dir}',
        f'--workpath={work_dir}',
        f'--specpath={spec_dir}',
        
        # Solo los imports esenciales
        '--hidden-import=PyQt6',
        '--hidden-import=PyQt6.QtCore',
        '--hidden-import=PyQt6.QtGui',
        '--hidden-import=PyQt6.QtWidgets',
        '--hidden-import=sounddevice',
        
        # Excluir scipy problem√°tico
        '--exclude-module=scipy',
        '--exclude-module=numpy.distutils',
    ]
    
    if os.path.exists(icon_path):
        args.append(f'--icon={icon_path}')
    
    print(f"üîß Construyendo versi√≥n simplificada: {exe_name}")
    try:
        PyInstaller.__main__.run(args)
        print("‚úÖ ¬°Versi√≥n simplificada completada!")
        return True
    except Exception as e:
        print(f"‚ùå Error en versi√≥n simplificada: {e}")
        return False

def build_with_spec_file():
    """SOLUCI√ìN 2: Crear archivo .spec personalizado"""
    timestamp = datetime.datetime.now().strftime('%y-%m-%d_%H-%M-%S')
    exe_name = f'voider-{timestamp}'
    
    base_dir = os.path.dirname(os.path.abspath(__file__))
    spec_content = f'''# -*- mode: python ; coding: utf-8 -*-

a = Analysis(
    ['voider.py'],
    pathex=['{base_dir.replace(chr(92), chr(92)+chr(92))}'],
    binaries=[],
    datas=[('voider.ico', '.')] if os.path.exists('voider.ico') else [],
    hiddenimports=[
        'PyQt6',
        'PyQt6.QtCore',
        'PyQt6.QtGui', 
        'PyQt6.QtWidgets',
        'sounddevice',
    ],
    hookspath=[],
    runtime_hooks=[],
    excludes=['scipy', 'matplotlib', 'tkinter', 'pygame', 'torch'],
    noarchive=False,
)

pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='{exe_name}',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon='voider.ico' if os.path.exists('voider.ico') else None,
)
'''
    
    spec_file = f'{exe_name}.spec'
    with open(spec_file, 'w') as f:
        f.write(spec_content)
    
    print(f"üìù Archivo .spec creado: {spec_file}")
    print("üîß Ejecuta manualmente: pyinstaller --clean " + spec_file)
    return spec_file

def build_conda_fix():
    """SOLUCI√ìN 3: Versi√≥n para entornos conda/problemas de dependencias"""
    timestamp = datetime.datetime.now().strftime('%y-%m-%d_%H-%M-%S')
    exe_name = f'voider-{timestamp}'
    
    base_dir = os.path.dirname(os.path.abspath(__file__))
    build_root = os.path.join(base_dir, 'builds')
    dist_dir = os.path.join(build_root, 'dist')
    work_dir = os.path.join(build_root, 'build')
    spec_dir = build_root
    main_script = os.path.join(base_dir, 'voider.py')
    
    os.makedirs(dist_dir, exist_ok=True)
    os.makedirs(work_dir, exist_ok=True)
    os.makedirs(spec_dir, exist_ok=True)
    
    args = [
        '--clean',
        '--onedir',
        '--console',  # Temporalmente para ver errores
        main_script,
        f'--name={exe_name}',
        f'--distpath={dist_dir}',
        f'--workpath={work_dir}',
        f'--specpath={spec_dir}',
        '--noupx',  # Desactivar UPX que a veces causa problemas
        '--debug=all',  # M√°s informaci√≥n de debug
    ]
    
    print(f"üîß Construyendo versi√≥n debug: {exe_name}")
    try:
        PyInstaller.__main__.run(args)
        print("‚úÖ ¬°Versi√≥n debug completada!")
        return True
    except Exception as e:
        print(f"‚ùå Error en versi√≥n debug: {e}")
        return False

def main():
    print("üöÄ Iniciando soluciones para PyInstaller...")
    print("=" * 50)
    
    # Informaci√≥n del sistema
    print("üìä Informaci√≥n del sistema:")
    print(f"   Python: {sys.version}")
    print(f"   Directorio: {os.getcwd()}")
    
    try:
        import PyInstaller
        print(f"   PyInstaller: {PyInstaller.__version__}")
    except:
        print("   PyInstaller: No disponible")
    
    try:
        import scipy
        print(f"   SciPy: {scipy.__version__}")
    except:
        print("   SciPy: No disponible")
    
    print("=" * 50)
    
    # Intentar soluciones en orden
    print("\n1Ô∏è‚É£ Intentando versi√≥n simplificada...")
    if build_simple():
        return
    
    print("\n2Ô∏è‚É£ Creando archivo .spec personalizado...")
    spec_file = build_with_spec_file()
    
    print("\n3Ô∏è‚É£ Intentando versi√≥n debug...")
    if build_conda_fix():
        return
    
    print("\n" + "=" * 50)
    print("üîß INSTRUCCIONES MANUALES:")
    print("=" * 50)
    print("Si nada funcion√≥ autom√°ticamente, prueba estos comandos manuales:")
    print()
    print("OPCI√ìN A - Sin scipy:")
    print("pyinstaller --onedir --windowed --clean voider.py --exclude-module=scipy")
    print()
    print("OPCI√ìN B - Solo lo esencial:")
    print("pyinstaller --onedir --console voider.py")
    print()
    print("OPCI√ìN C - Usar el .spec generado:")
    print(f"pyinstaller --clean {spec_file}")
    print()
    print("OPCI√ìN D - Actualizar PyInstaller:")
    print("pip install --upgrade pyinstaller")
    print()
    print("OPCI√ìN E - Crear entorno virtual limpio:")
    print("python -m venv venv_clean")
    print("venv_clean\\Scripts\\activate")
    print("pip install PyQt6 sounddevice pyinstaller")

if __name__ == "__main__":
    main()

# --- combined_code.py ---
import os

output_file = "combined_code.txt"
excluded_files = {
    "build_installer.py",
    "combined_py.py",
    "interface.py",
    "nuitka_build_installer.py",
    "realtime_effects.py",
    "test.py",
}

included_files = []

with open(output_file, "w", encoding="utf-8") as outfile:
    for file in os.listdir("."):
        if file.endswith(".py") and file not in excluded_files:
            included_files.append(file)
            with open(file, "r", encoding="utf-8") as infile:
                outfile.write(f"\n\n# --- {file} ---\n")    
                outfile.write(infile.read())

print(f"‚úÖ Combined .py files into '{output_file}'")
print("üóÇÔ∏è Archivos incluidos:")
for f in included_files:
    print(f" - {f}")


# --- controls.py ---
# --- controls.py ---
import random
import os

def setup_controls(app):
    """Configura los controles de la aplicaci√≥n."""
    print("Configurando controles...")

def show_random_line_from_current_file(app, event=None):
    """Muestra una l√≠nea aleatoria del archivo activo."""
    try:
        if os.path.exists(app.current_file_path):
            with open(app.current_file_path, 'r', encoding='utf-8') as f:
                lines = [line.strip() for line in f.readlines() if line.strip()]
            
            if lines:
                random_line = random.choice(lines)
                app.current_active_line = random_line
                with open(app.current_file_path, 'r', encoding='utf-8') as f:
                    all_lines = f.readlines()
                    for i, line in enumerate(all_lines):
                        if line.strip() == random_line:
                            app.current_active_line_index = i
                            break
                app.entry.setText(random_line)
                print(f"L√≠nea aleatoria mostrada del archivo activo: {random_line}")
            else:
                print(f"El archivo {os.path.basename(app.current_file_path)} est√° vac√≠o.")
                app.current_active_line = None
                app.current_active_line_index = None
                app.entry.clear()
        else:
            print(f"El archivo {os.path.basename(app.current_file_path)} no existe.")
            app.current_active_line = None
            app.current_active_line_index = None
            app.entry.clear()
    except Exception as e:
        print(f"Error al mostrar l√≠nea aleatoria del archivo activo: {e}")
        app.current_active_line = None
        app.current_active_line_index = None
        app.entry.clear()

def show_random_line_from_random_file(app, event=None):
    """Muestra una l√≠nea aleatoria de un archivo .txt aleatorio de txt_files."""
    try:
        if not app.txt_files:
            print("No hay archivos .txt disponibles para seleccionar.")
            app.current_active_line = None
            app.current_active_line_index = None
            app.entry.clear()
            return
        
        # Select a random file from txt_files
        random_file = random.choice(app.txt_files)
        
        # Switch to the selected file (updates current_file_path and resets state)
        app.switch_to_file(random_file)
        
        # Read lines from the selected file
        with open(random_file, 'r', encoding='utf-8') as f:
            lines = [line.strip() for line in f.readlines() if line.strip()]
        
        if lines:
            random_line = random.choice(lines)
            app.current_active_line = random_line
            with open(random_file, 'r', encoding='utf-8') as f:
                all_lines = f.readlines()
                for i, line in enumerate(all_lines):
                    if line.strip() == random_line:
                        app.current_active_line_index = i
                        break
            app.entry.setText(random_line)
            print(f"L√≠nea aleatoria mostrada del archivo {os.path.basename(random_file)}: {random_line}")
        else:
            print(f"El archivo {os.path.basename(random_file)} est√° vac√≠o.")
            app.current_active_line = None
            app.current_active_line_index = None
            app.entry.clear()
    except Exception as e:
        print(f"Error al mostrar l√≠nea aleatoria de archivo aleatorio: {e}")
        app.current_active_line = None
        app.current_active_line_index = None
        app.entry.clear()

def show_previous_current_file_line(app, event=None):
    """Muestra la l√≠nea anterior en el archivo activo."""
    try:
        if os.path.exists(app.current_file_path):
            with open(app.current_file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            
            if not lines:
                print(f"El archivo {os.path.basename(app.current_file_path)} est√° vac√≠o.")
                app.current_active_line = None
                app.current_active_line_index = None
                app.entry.clear()
                return
            
            current_index = app.current_active_line_index if app.current_active_line_index is not None else len(lines)
            new_index = current_index - 1
            
            while new_index >= 0:
                if lines[new_index].strip():
                    app.current_active_line_index = new_index
                    app.current_active_line = lines[new_index].strip()
                    app.entry.setText(app.current_active_line)
                    print(f"L√≠nea anterior mostrada: {app.current_active_line}")
                    return
                new_index -= 1
            
            print("No hay l√≠neas anteriores no vac√≠as.")
            app.current_active_line = None
            app.current_active_line_index = None
            app.entry.clear()
        else:
            print(f"El archivo {os.path.basename(app.current_file_path)} no existe.")
            app.current_active_line = None
            app.current_active_line_index = None
            app.entry.clear()
    except Exception as e:
        print(f"Error al mostrar l√≠nea anterior: {e}")
        app.current_active_line = None
        app.current_active_line_index = None
        app.entry.clear()

def show_next_current_file_line(app, event=None):
    """Muestra la l√≠nea siguiente en el archivo activo."""
    try:
        if os.path.exists(app.current_file_path):
            with open(app.current_file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            
            if not lines:
                print(f"El archivo {os.path.basename(app.current_file_path)} est√° vac√≠o.")
                app.current_active_line = None
                app.current_active_line_index = None
                app.entry.clear()
                return
            
            current_index = app.current_active_line_index if app.current_active_line_index is not None else -1
            new_index = current_index + 1
            
            while new_index < len(lines):
                if lines[new_index].strip():
                    app.current_active_line_index = new_index
                    app.current_active_line = lines[new_index].strip()
                    app.entry.setText(app.current_active_line)
                    print(f"L√≠nea siguiente mostrada: {app.current_active_line}")
                    return
                new_index += 1
            
            print("No hay l√≠neas siguientes no vac√≠as.")
            app.current_active_line = None
            app.current_active_line_index = None
            app.entry.clear()
        else:
            print(f"El archivo {os.path.basename(app.current_file_path)} no existe.")
            app.current_active_line = None
            app.current_active_line_index = None
            app.entry.clear()
    except Exception as e:
        print(f"Error al mostrar l√≠nea siguiente: {e}")
        app.current_active_line = None
        app.current_active_line_index = None
        app.entry.clear()

# --- files.py ---
# --- files.py ---
import os
import random
import re
import datetime
import sys

def setup_file_handling(app):
    """Initializes file handling for the active file and ensures void_dir exists."""
    # Ensure void_dir exists
    if not os.path.exists(app.void_dir):
        os.makedirs(app.void_dir)
    
    # Ensure the active file (current_file_path) exists
    if not os.path.exists(app.current_file_path):
        with open(app.current_file_path, 'w', encoding='utf-8') as f:
            f.write('')
        print(f"Created active file: {app.current_file_path}")
    
    # Ensure 0.txt exists (as a fallback or for commands like //)
    if not os.path.exists(app.void_file_path):
        with open(app.void_file_path, 'w', encoding='utf-8') as f:
            f.write('')
        print(f"Created 0.txt: {app.void_file_path}")
    
    # Initialize navigation state
    app.current_active_line = None
    app.current_active_line_index = None
    app.last_inserted_index = None
    print(f"File handling initialized. Active file: {app.current_file_path}")

def void_line(app, event=None):
    """Procesa la l√≠nea ingresada, formate√°ndola y guard√°ndola en el archivo activo,
       o ejecutando un comando de archivo (cambiar o mover bloques/l√≠neas)."""
    try:
        line = app.entry.text().strip()
        app.entry.clear()
        app.entry.setFocus()

        if not line:
            app.current_active_line_index = None 
            app.current_active_line = None
            
            # --- MODIFICACI√ìN AQU√ç: Mover al final del archivo si la entrada est√° vac√≠a ---
            lines_in_file = []
            if os.path.exists(app.current_file_path):
                with open(app.current_file_path, 'r', encoding='utf-8') as f:
                    lines_in_file = f.readlines()
            
            # Establecer last_inserted_index al √≠ndice de la √∫ltima l√≠nea (o -1 si est√° vac√≠o)
            # Esto asegura que la pr√≥xima inserci√≥n se haga al final del archivo.
            app.last_inserted_index = len(lines_in_file) - 1 

            print(f"Input vac√≠o: Reiniciando √≠ndice de l√≠nea activa y estableciendo last_inserted_index a {app.last_inserted_index} (final del archivo).")
            return # No hacer nada m√°s si la l√≠nea est√° vac√≠a
        # --- FIN MODIFICACI√ìN ---

        # --- Nuevo: Verificar si se intenta a√±adir un punto consecutivo ---
        last_line_in_file = None
        if os.path.exists(app.current_file_path):
            with open(app.current_file_path, 'r', encoding='utf-8') as f:
                # Leer l√≠neas en reversa para encontrar la √∫ltima l√≠nea no vac√≠a eficientemente
                # y evitar cargar todo el archivo en memoria si es muy grande.
                lines = f.readlines()
                for l in reversed(lines):
                    stripped_l = l.strip()
                    if stripped_l: # Encontrar la √∫ltima l√≠nea que no est√© vac√≠a
                        last_line_in_file = stripped_l
                        break

        # Si la entrada es un solo punto y la √∫ltima l√≠nea en el archivo tambi√©n es un solo punto,
        # entonces no se procesa esta entrada.
        if line == '.' and last_line_in_file == '.':
            print("Se evit√≥ a√±adir puntos √∫nicos consecutivos.")
            app.current_active_line_index = None
            app.current_active_line = None
            app.last_inserted_index = None
            return # No procesar esta entrada

        # --- 1. Manejo de comandos de cambio de archivo (//) ---
        if line.startswith("//"):
            target_filename = line[2:].strip()
            if not target_filename: # Si solo se escribe "//", ir a 0.txt
                target_filename = "0" 
            
            # Normalizar el nombre del archivo
            if not target_filename.lower().endswith(".txt"):
                target_filename += ".txt"
            
            new_file_full_path = os.path.join(app.void_dir, target_filename)

            if new_file_full_path != app.current_file_path:
                # Cambiar el archivo activo
                app.current_file_path = new_file_full_path
                # Crear el archivo si no existe
                if not os.path.exists(app.current_file_path):
                    with open(app.current_file_path, 'w', encoding='utf-8') as f:
                        f.write('')
                    print(f"Archivo creado: {os.path.basename(app.current_file_path)}")
                
                # Update txt_files and current_file_index
                if new_file_full_path not in app.txt_files:
                    app.txt_files.append(new_file_full_path)
                    app.txt_files.sort()
                app.current_file_index = app.txt_files.index(new_file_full_path)
                
                print(f"Cambiado al archivo: {os.path.basename(app.current_file_path)}")
                # Resetear el estado de navegaci√≥n para el nuevo archivo
                app.current_active_line = None
                app.current_active_line_index = None
                app.last_inserted_index = None
            else:
                print(f"Ya est√°s en el archivo: {os.path.basename(app.current_file_path)}")
            return # Finalizar procesamiento de esta l√≠nea

        # --- 2. Manejo de "Mover una Sola L√≠nea" (Ej: "Mi contenido /nombre_archivo") ---
        # Busca el patr√≥n de texto seguido de un espacio y el comando /filename al final de la l√≠nea.
        match_single_line_move = re.search(r'(.*)\s+/([a-zA-Z0-9_.-]+\.txt|[a-zA-Z0-9_.-]+)$', line)
        
        if match_single_line_move:
            content_to_move = match_single_line_move.group(1).strip()
            target_filename_raw = match_single_line_move.group(2).strip()

            if not target_filename_raw:
                print("Comando de mover l√≠nea incompleto.")
                return

            target_filename = target_filename_raw
            if not target_filename.lower().endswith(".txt"):
                target_filename += ".txt"
            target_file_path = os.path.join(app.void_dir, target_filename)

            # Asegurar que el archivo de destino exista
            if not os.path.exists(target_file_path):
                with open(target_file_path, 'w', encoding='utf-8') as f:
                    f.write('')
            
            # Mover el contenido al archivo de destino
            with open(target_file_path, 'a', encoding='utf-8') as target_f:
                target_f.write(content_to_move + '\n')
            print(f"L√≠nea '{content_to_move}' movida a {os.path.basename(target_file_path)}")

            # Ahora, eliminar la l√≠nea del archivo de origen si fue una edici√≥n/reemplazo
            if app.current_active_line_index is not None:
                all_file_lines = []
                if os.path.exists(app.current_file_path):
                    with open(app.current_file_path, 'r', encoding='utf-8') as f:
                        all_file_lines = f.readlines()
                
                # Eliminar la l√≠nea original que conten√≠a el comando
                if app.current_active_line_index < len(all_file_lines):
                    del all_file_lines[app.current_active_line_index]
                
                # Reescribir el archivo de origen
                with open(app.current_file_path, 'w', encoding='utf-8') as current_f:
                    current_f.writelines(all_file_lines)
                    current_f.flush()
                    os.fsync(current_f.fileno())
                
                # Si el archivo de origen queda vac√≠o despu√©s de eliminar la l√≠nea (y no es 0.txt), eliminarlo
                if not all_file_lines and app.current_file_path != app.void_file_path:
                    os.remove(app.current_file_path)
                    print(f"Archivo {os.path.basename(app.current_file_path)} vac√≠o y eliminado.")
                    app.current_file_path = app.void_file_path # Volver a 0.txt
                    app.current_file_index = app.txt_files.index(app.current_file_path)
                    print(f"Regresando al archivo: {os.path.basename(app.current_file_path)}")

            app.current_active_line = None
            app.current_active_line_index = None
            app.last_inserted_index = None
            return # Finalizar procesamiento de esta l√≠nea

        # --- 3. Manejo de "Mover Bloque Completo" (Ej: "/nombre_archivo" en una l√≠nea sola) ---
        if line.startswith("/"): # Solo si no fue manejado por el caso anterior
            target_filename_raw = line[1:].strip()
            if not target_filename_raw:
                print("Comando de mover bloque incompleto. Escribe /nombre_archivo.txt")
                return
            
            target_filename = target_filename_raw
            if not target_filename.lower().endswith(".txt"):
                target_filename += ".txt"
            target_file_path = os.path.join(app.void_dir, target_filename)

            all_file_lines = []
            if os.path.exists(app.current_file_path):
                with open(app.current_file_path, 'r', encoding='utf-8') as f:
                    all_file_lines = f.readlines()
            
            # Determinar el √≠ndice donde el comando fue/ser√° insertado
            command_insert_index = len(all_file_lines) # Por defecto, al final
            if app.current_active_line_index is not None:
                command_insert_index = app.current_active_line_index
            
            # Encontrar el inicio del bloque a mover (√∫ltimo punto antes de command_insert_index)
            block_start_index = 0
            for i in range(command_insert_index - 1, -1, -1):
                if all_file_lines[i].strip() == '.':
                    block_start_index = i
                    break
            
            # Extraer el bloque a mover
            block_to_move = all_file_lines[block_start_index : command_insert_index]
            
            # >>> CORRECCI√ìN: NUNCA insertar el comando como texto normal si no hay bloque <<<
            if not block_to_move:
                print(f"No se encontr√≥ un bloque para mover con el comando '{line}'. No se realiz√≥ ninguna acci√≥n en el archivo.")
                app.current_active_line = None
                app.current_active_line_index = None
                app.last_inserted_index = None
                return # Simplemente retornar, sin modificar el archivo de origen.

            # Asegurar que el archivo de destino exista
            if not os.path.exists(target_file_path):
                with open(target_file_path, 'w', encoding='utf-8') as f:
                    f.write('')
            
            # >>> NUEVA L√ìGICA: A√±adir punto al inicio del bloque en el archivo de destino <<<
            with open(target_file_path, 'r+', encoding='utf-8') as target_f: # Abrir para leer y escribir
                target_content = target_f.read()
                # Si el archivo est√° vac√≠o o no termina con un punto, a√±adir un punto antes del bloque
                if not target_content.strip() or target_content.strip().endswith('.'):
                    # Si termina con un punto, o est√° vac√≠o, a√±adir el bloque directamente
                    # (el punto inicial del bloque se a√±adir√° al escribir)
                    pass 
                else: # Si termina sin punto, pero no est√° vac√≠o, asegurar que haya un punto antes de a√±adir el nuevo bloque
                    target_f.write('.\n') # A√±adir un punto para separar el bloque anterior del nuevo

                # Mover el puntero al final del archivo para a√±adir el nuevo contenido
                target_f.seek(0, os.SEEK_END)
                
                # El bloque debe empezar con un punto en el destino
                final_block_to_write = []
                if not block_to_move[0].strip() == '.': # Si el bloque no empieza ya con un punto, a√±adir uno
                    final_block_to_write.append('.\n')
                final_block_to_write.extend(block_to_move)

                target_f.writelines(final_block_to_write)
            
            # --- CORRECCI√ìN: El comando NO se incluye en new_source_lines aqu√≠. ---
            # Construir las nuevas l√≠neas del archivo de origen:
            # L√≠neas antes del bloque + l√≠neas despu√©s de la l√≠nea del comando (excluyendo el comando)
            new_source_lines = all_file_lines[:block_start_index] + all_file_lines[command_insert_index + 1:]

            # >>> NUEVA L√ìGICA: Reinsertar punto en el archivo de origen si es necesario <<<
            # Esto ocurre si hab√≠a contenido antes Y despu√©s del bloque extra√≠do,
            # y la l√≠nea justo antes del bloque extra√≠do NO era ya un punto.
            if block_start_index > 0 and command_insert_index + 1 <= len(all_file_lines): # <= para incluir el caso de que command_insert_index sea el √∫ltimo
                # Verificar si la l√≠nea que estaba justo antes del inicio del bloque movido (all_file_lines[block_start_index - 1])
                # era un punto. Si no lo era, y el bloque que se movi√≥ S√ç comenz√≥ con un punto
                # (o simplemente hay una brecha entre dos secciones que ahora necesitan un punto)
                # entonces reinsertamos un punto en el origen.
                
                # Si la l√≠nea justo ANTES de la brecha no era un punto
                # Y hay contenido ANTES y DESPU√âS de la brecha.
                if all_file_lines[block_start_index - 1].strip() != '.':
                    # Insertar un punto en la posici√≥n donde sol√≠a comenzar el bloque movido
                    new_source_lines.insert(block_start_index, '.\n')

            # Reescribir el archivo de origen
            with open(app.current_file_path, 'w', encoding='utf-8') as current_f:
                current_f.writelines(new_source_lines)
                current_f.flush()
                os.fsync(current_f.fileno())

            print(f"Bloque movido de {os.path.basename(app.current_file_path)} a {os.path.basename(target_file_path)}")
            
            # Si el archivo de origen queda completamente vac√≠o (incluyendo la ausencia del comando), y no es 0.txt, eliminarlo.
            if not new_source_lines and app.current_file_path != app.void_file_path:
                os.remove(app.current_file_path)
                print(f"Archivo {os.path.basename(app.current_file_path)} vac√≠o y eliminado.")
                app.current_file_path = app.void_file_path # Volver a 0.txt
                app.current_file_index = app.txt_files.index(app.current_file_path)
                print(f"Regresando al archivo: {os.path.basename(app.current_file_path)}")

            app.current_active_line = None
            app.current_active_line_index = None
            app.last_inserted_index = None
            return # Finalizar procesamiento de esta l√≠nea

        # --- 4. Manejo de texto normal (si no es un comando) ---
        # MODIFICACI√ìN APLICADA AQU√ç (Opci√≥n 1)
        if line == '.': # <-- Si la l√≠nea es SOLO un punto, la tratamos de forma especial
            formatted_lines = ['.'] # La lista de l√≠neas formateadas es solo un punto.
        else: 
            protected = line.replace("...", "<ELLIPSIS>")
            raw_sentences = re.split(r'\.(?=\s|$)', protected) 
            formatted_lines = []
            for raw in raw_sentences:
                s = raw.strip()
                if not s:
                    continue
                s = s.replace("<ELLIPSIS>", "...") 
                s = s[0].upper() + s[1:] if s else s
                if not s.endswith('.') and not s.endswith('...'):
                    s += '.'
                formatted_lines.append(s) 
        formatted_text = '\n'.join(formatted_lines)
        # --- FIN FORMATO ---

        # Leer l√≠neas del archivo activo
        with open(app.current_file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines() 

        if hasattr(app, 'current_active_line_index') and app.current_active_line_index is not None:
            # Si estamos editando una l√≠nea existente (navegaci√≥n previa/siguiente)
            if app.current_active_line_index < len(lines): 
                lines[app.current_active_line_index] = formatted_text + '\n'
                app.last_inserted_index = app.current_active_line_index
            app.current_active_line_index = None 
            app.current_active_line = None
        else:
            # Si estamos a√±adiendo una nueva l√≠nea
            insert_index = (app.last_inserted_index + 1) if hasattr(app, 'last_inserted_index') and app.last_inserted_index is not None else len(lines)
            
            # Asegurarse de que el √≠ndice de inserci√≥n no exceda el n√∫mero de l√≠neas existentes + 1
            if insert_index > len(lines):
                insert_index = len(lines)

            lines[insert_index:insert_index] = [line_to_add + '\n' for line_to_add in formatted_lines]
            app.last_inserted_index = insert_index + len(formatted_lines) - 1 
            app.current_active_line_index = None
            app.current_active_line = None

        # Escribir todas las l√≠neas de vuelta al archivo activo
        with open(app.current_file_path, 'w', encoding='utf-8') as f:
            f.writelines(lines)
            f.flush()
            os.fsync(f.fileno())
        
        print(f"L√≠neas insertadas/modificadas en {os.path.basename(app.current_file_path)}.") 

    except Exception as e:
        print(f"Error en void_line: {e}") 
        app.entry.clear()
        app.entry.setFocus()

# --- new_interface.py ---
# --- new_interface.py ---
import os
import sys
import numpy as np
from PyQt6.QtWidgets import QApplication, QMainWindow, QLineEdit, QLabel, QWidget
from PyQt6.QtGui import QColor, QPainter, QFont, QCursor, QPen, QPixmap, QImage
from PyQt6.QtCore import Qt, QTimer
from files import setup_file_handling, void_line
from controls import setup_controls, show_random_line_from_current_file, show_previous_current_file_line, show_next_current_file_line, show_random_line_from_random_file
from noise_controls import NoiseController

class CustomLineEdit(QLineEdit):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent

    def keyPressEvent(self, event):
        key = event.key()
        modifiers = event.modifiers()
        
        if key == Qt.Key.Key_0:
            # Trigger random line from a random file
            if '/' not in self.text(): 
                print("Key 0 detected in QLineEdit without slash, executing show_random_line_from_random_file") 
                self.parent.last_inserted_index = None 
                show_random_line_from_random_file(self.parent, event)
                event.accept() # Consume the event so '0' isn't written
            else:
                # If there's a slash, allow '0' to be written normally
                super().keyPressEvent(event) 
        elif key == Qt.Key.Key_Period:
            # Trigger random line from the current file
            if '/' not in self.text(): 
                print("Key . detected in QLineEdit without slash, executing show_random_line_from_current_file") 
                self.parent.last_inserted_index = None 
                show_random_line_from_current_file(self.parent, event)
                event.accept() # Consume the event so '.' isn't written
            else:
                # If there's a slash, allow '.' to be written normally
                super().keyPressEvent(event) 
        elif (key == Qt.Key.Key_Up or key == Qt.Key.Key_Down) and modifiers == Qt.KeyboardModifier.ControlModifier:
            self.parent.keyPressEvent(event)
        else:
            super().keyPressEvent(event)

class CircleBackground(QWidget):
    def __init__(self, parent=None, center_x=0, center_y=0, radius=0):
        super().__init__(parent)
        self.center_x = center_x 
        self.center_y = center_y
        self.radius = radius
        self.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        pen = QPen(QColor("white"), 10)
        painter.setPen(pen)
        painter.setBrush(Qt.BrushStyle.NoBrush)
        painter.drawEllipse(
            self.center_x - self.radius, 
            self.center_y - self.radius,
            self.radius * 2,
            self.radius * 2
        )

    def resizeEvent(self, event):
        self.resize(self.parent().size())

class NoiseOverlay(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents) 
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.noise_pixmap = None
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.generate_noise)
        self.timer.start(50)

    def generate_noise(self):
        block_size = 1
        w, h = self.width(), self.height()
        h_blocks, w_blocks = h // block_size, w // block_size
        noise_gray = np.random.randint(0, 256, (h_blocks, w_blocks), dtype=np.uint8) 
        image = QImage(noise_gray.data, w_blocks, h_blocks, w_blocks, QImage.Format.Format_Grayscale8)
        image = image.scaled(w, h, Qt.AspectRatioMode.IgnoreAspectRatio, Qt.TransformationMode.FastTransformation)
        self.noise_pixmap = QPixmap.fromImage(image)
        self.update()

    def paintEvent(self, event):
        if self.noise_pixmap:
            painter = QPainter(self)
            painter.setOpacity(0.09)  # More visible 
            painter.drawPixmap(0, 0, self.noise_pixmap)

class FullscreenCircleApp(QMainWindow):
    def __init__(self, read_dir=None, void_dir=None, file_to_open=None):
        super().__init__()
        self.opacity = 1.0
        self.read_dir = read_dir
        self.void_dir = void_dir
        self.file_to_open = file_to_open
        self.txt_files = []  # List to store .txt files in the directory
        self.current_file_index = 0  # Index of the current file in txt_files
        
        self.setWindowTitle("Voider")
        self.setWindowFlag(Qt.WindowType.FramelessWindowHint)
        self.setCursor(QCursor(Qt.CursorShape.BlankCursor))
        self.setStyleSheet("background-color: black;")

        self.entry = CustomLineEdit(self) 
        self.entry.setFont(QFont("Consolas", 11))
        self.entry.setStyleSheet("""
            QLineEdit {
                background-color: black;
                color: white; 
                border: none;
                qproperty-alignment: AlignCenter;
                selection-background-color: white;
                selection-color: black;
            }
        """) 
        self.entry.setFocus()
        self.entry.returnPressed.connect(lambda: void_line(self)) 

        self.loading = QLabel("Loading potentiality", self)
        self.loading.setFont(QFont("Consolas", 11))
        self.loading.setStyleSheet("color: white; background-color: black;")
        self.loading.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.loading.resize(300, 100)
        self.loading.hide()

        self.noise_controller = NoiseController(
            block_size=1024, volume=0.3, noise_type='brown', 
            bitcrush={'bit_depth': 10, 'sample_rate_factor': 0.7},
            lfo_min_freq=0.03, lfo_max_freq=0.1, glitch_prob=0.005, cutoff_freq=2500
        )

        self.setup_voider_logic()
        self.init_ui()

    def setup_voider_logic(self):
        # Set the current file path based on file_to_open
        if self.file_to_open:
            self.current_file_path = self.file_to_open
        else:
            self.current_file_path = os.path.join(self.void_dir, '0.txt')
        
        self.void_file_path = os.path.join(self.void_dir, '0.txt')  # Keep reference to 0.txt
        print(f"void_file_path (0.txt): {self.void_file_path}")
        print(f"current_file_path (active file): {self.current_file_path}")
        
        # Scan the directory for .txt files
        self.scan_txt_files()
        
        self.current_active_line = None 
        self.current_active_line_index = None 
        self.last_inserted_index = None 
        setup_file_handling(self)  # This will ensure the file exists
        setup_controls(self)

    def scan_txt_files(self):
        """Scans the directory of the current file for .txt files and stores them in txt_files."""
        dir_path = os.path.dirname(self.current_file_path)
        self.txt_files = [
            os.path.join(dir_path, f) for f in os.listdir(dir_path)
            if f.lower().endswith('.txt') and os.path.isfile(os.path.join(dir_path, f))
        ]
        self.txt_files.sort()  # Sort alphabetically for consistent navigation
        if self.current_file_path in self.txt_files:
            self.current_file_index = self.txt_files.index(self.current_file_path)
        else:
            self.txt_files.append(self.current_file_path)
            self.txt_files.sort()
            self.current_file_index = self.txt_files.index(self.current_file_path)
        print(f"Found {len(self.txt_files)} .txt files in {dir_path}: {self.txt_files}")

    def switch_to_file(self, file_path):
        """Switches the active file to the specified file_path and resets state."""
        if not os.path.exists(file_path):
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write('')
            print(f"Created file: {file_path}")
        
        self.current_file_path = file_path
        self.current_file_index = self.txt_files.index(file_path)
        self.current_active_line = None
        self.current_active_line_index = None
        self.last_inserted_index = None
        self.entry.clear()
        print(f"Switched to file: {os.path.basename(file_path)}, Index: {self.current_file_index}")

    def show_previous_file(self):
        """Switches to the previous .txt file in the list."""
        if not self.txt_files:
            print("No .txt files available to navigate.")
            return
        self.current_file_index = (self.current_file_index - 1) % len(self.txt_files)
        self.switch_to_file(self.txt_files[self.current_file_index])

    def show_next_file(self):
        """Switches to the next .txt file in the list."""
        if not self.txt_files:
            print("No .txt files available to navigate.")
            return
        self.current_file_index = (self.current_file_index + 1) % len(self.txt_files)
        self.switch_to_file(self.txt_files[self.current_file_index])

    def init_ui(self):
        print("Initializing UI")
        self.showFullScreen()
        screen = self.screen().availableGeometry()
        self.center_x = screen.width() // 2
        self.center_y = screen.height() // 2
        self.radius = min(screen.width(), screen.height()) // 2 - 35 
        entry_width = self.radius * 2 - 40
        self.entry.setFixedWidth(entry_width)
        self.entry.move(self.center_x - entry_width // 2,
                        self.center_y - self.entry.height() // 2)
        self.loading.move(self.center_x - 150, self.center_y - 50)
        self.loading.show()
        QTimer.singleShot(1500, self.loading.deleteLater) 

        self.circle_background = CircleBackground(self, self.center_x, self.center_y, self.radius)
        self.circle_background.resize(self.size())
        self.circle_background.show()

        self.noise_overlay = NoiseOverlay(self)
        self.noise_overlay.resize(self.size())
        self.noise_overlay.show()
        self.noise_overlay.raise_() # Put it on top of everything

    def resizeEvent(self, event):
        super().resizeEvent(event)
        if hasattr(self, 'noise_overlay'):
            self.noise_overlay.resize(self.size()) 
        if hasattr(self, 'circle_background'):
            self.circle_background.resize(self.size())

    def keyPressEvent(self, event):
        key = event.key()
        modifiers = event.modifiers()
        print(f"Key in window: {key}, Modifiers: {modifiers}")

        if key == Qt.Key.Key_Escape:
            self.noise_controller.stop()
            self.close() 
        elif key == Qt.Key.Key_Up and modifiers == Qt.KeyboardModifier.ControlModifier:
            self.increase_opacity()
        elif key == Qt.Key.Key_Down and modifiers == Qt.KeyboardModifier.ControlModifier:
            self.decrease_opacity()
        elif key == Qt.Key.Key_Up and modifiers == Qt.KeyboardModifier.AltModifier:
            self.show_previous_file()
        elif key == Qt.Key.Key_Down and modifiers == Qt.KeyboardModifier.AltModifier:
            self.show_next_file()
        elif key == Qt.Key.Key_Up:
            show_previous_current_file_line(self) # Updated for active file
        elif key == Qt.Key.Key_Down:
            show_next_current_file_line(self) # Updated for active file

    def increase_opacity(self):
        self.opacity = min(1.0, self.opacity + 0.1)
        self.setWindowOpacity(self.opacity)

    def decrease_opacity(self):
        self.opacity = max(0.0, self.opacity - 0.1)
        self.setWindowOpacity(self.opacity)

# --- noise_controls.py ---
# --- noise_controls.py ---
import numpy as np
import sounddevice as sd
from PyQt6.QtCore import QTimer

class NoiseController:
    def __init__(self, sample_rate=44100, block_size=1024, volume=0.01, noise_type='brown',
                 bitcrush={'bit_depth': 8, 'sample_rate_factor': 0.6},
                 lfo_min_freq=0.01, lfo_max_freq=0.03, glitch_prob=0.001, cutoff_freq=300):
        self.sample_rate = sample_rate
        self.block_size = block_size
        self.volume = volume
        self.noise_type = noise_type
        self.bitcrush = bitcrush
        self.lfo_min_freq = lfo_min_freq
        self.lfo_max_freq = lfo_max_freq
        self.glitch_prob = glitch_prob
        self.cutoff_freq = cutoff_freq
        self.stream = None
        self.timer = None
        self.lfo_state = 0

        try:
            self.stream = sd.OutputStream(
                samplerate=sample_rate,
                blocksize=block_size,
                channels=2,
                callback=self.audio_callback
            )
            self.stream.start()
            self.start_lfo_generator()
            print(f"NoiseController: {self.noise_type.capitalize()} subtle meditative noise started.")
        except Exception as e:
            print(f"NoiseController: Error initializing audio: {str(e)}")

    def lowpass_filter(self, data, cutoff, alpha=0.1):
        """
        Filtro pasa bajos simple usando un filtro de media m√≥vil exponencial.
        `alpha` controla la suavidad (m√°s bajo = m√°s suave).
        """
        filtered = np.zeros_like(data)
        filtered[0] = data[0]
        for i in range(1, len(data)):
            filtered[i] = alpha * data[i] + (1 - alpha) * filtered[i - 1]
        return filtered

    def apply_bitcrush(self, noise, bit_depth=16, sample_rate_factor=1.0):
        original_length = len(noise)
        if sample_rate_factor < 1.0:
            new_length = int(original_length * sample_rate_factor)
            new_length = max(1, new_length)
            indices = np.linspace(0, original_length - 1, new_length).astype(int)
            noise = noise[indices]
            noise = np.tile(noise, (original_length // len(noise) + 1))[:original_length]
        if bit_depth < 16:
            max_val = 2 ** (bit_depth - 1) - 1
            noise = np.round(noise / 32767 * max_val) / max_val * 32767
        return noise.astype(np.int16)

    def generate_variable_lfo(self, t, min_freq, max_freq):
        n_points = 4
        rand_freqs = np.random.uniform(min_freq, max_freq, n_points)
        rand_phases = np.random.uniform(0, 2 * np.pi, n_points)
        key_times = np.linspace(0, self.block_size / self.sample_rate, n_points)
        freqs = np.interp(t, key_times, rand_freqs)
        phases = np.interp(t, key_times, rand_phases)
        return 0.97 + 0.03 * np.sin(2 * np.pi * freqs * t + phases)

    def audio_callback(self, outdata, frames, time, status):
        if status:
            print(f"Audio callback status: {status}")
        if frames != self.block_size:
            return

        if self.noise_type == 'brown':
            white = np.random.uniform(-1, 1, frames)
            brown = np.cumsum(white)
            noise = brown / np.max(np.abs(brown)) * 0.8
        elif self.noise_type == 'white':
            noise = np.random.uniform(-1, 1, frames)
        elif self.noise_type == 'pink':
            white = np.random.uniform(-1, 1, frames)
            pink = np.cumsum(white) / np.arange(1, frames + 1) ** 0.5
            noise = pink / np.max(np.abs(pink)) * 0.8
        else:
            noise = np.zeros(frames)

        noise = self.lowpass_filter(noise, cutoff=self.cutoff_freq)

        t = np.linspace(self.lfo_state, self.lfo_state + frames / self.sample_rate, frames)
        self.lfo_state += frames / self.sample_rate
        noise *= self.generate_variable_lfo(t, self.lfo_min_freq, self.lfo_max_freq)

        if np.random.rand() < 0.25:  # reducir cantidad de glitches
            glitch_mask = np.random.random(frames) < self.glitch_prob
            noise[glitch_mask] *= np.random.uniform(0.9, 1.1, glitch_mask.sum())

        if self.bitcrush:
            bit_depth = self.bitcrush.get('bit_depth', 8)
            sample_rate_factor = self.bitcrush.get('sample_rate_factor', 0.6)
            noise = (noise * 32767).astype(np.float32)
            noise = self.apply_bitcrush(noise, bit_depth, sample_rate_factor)

        noise = noise / np.max(np.abs(noise)) * 0.1 * self.volume
        stereo_noise = np.repeat(noise[:, np.newaxis], 2, axis=1)
        outdata[:] = stereo_noise

    def start_lfo_generator(self):
        self.timer = QTimer()
        self.timer.timeout.connect(lambda: None)
        self.timer.start(100)

    def stop(self):
        if self.stream:
            self.stream.stop()
            self.stream.close()
        if self.timer:
            self.timer.stop()
        print("NoiseController: Stopped")

    def set_volume(self, volume):
        self.volume = max(0.0, min(1.0, volume))
        print(f"NoiseController: Volume set to {self.volume:.2f}")

    def set_noise_type(self, noise_type):
        self.noise_type = noise_type
        print(f"NoiseController: Noise type set to {self.noise_type}")

    def set_bitcrush(self, bitcrush):
        self.bitcrush = bitcrush
        print(f"NoiseController: Bitcrush set to {self.bitcrush}")

    def set_lfo_freq(self, min_freq, max_freq):
        self.lfo_min_freq = min_freq
        self.lfo_max_freq = max_freq
        print(f"NoiseController: LFO freq range set to {min_freq:.2f}-{max_freq:.2f} Hz")

    def set_glitch_prob(self, prob):
        self.glitch_prob = max(0.0, min(0.1, prob))
        print(f"NoiseController: Glitch probability set to {self.glitch_prob:.4f}")

    def set_cutoff_freq(self, cutoff):
        self.cutoff_freq = max(50, min(8000, cutoff))
        print(f"NoiseController: Cutoff frequency set to {self.cutoff_freq} Hz")


# --- tools.py ---
# --- tools.py ---
def clean_text(text):
    return text  # Devolver texto sin cambios

def close_program(app, event=None):
    app.close()

def show_cursor(app, event=None):
    app.entry.setCursorVisible(True)

# --- voider.py ---
# --- voider.py ---
import os
import sys
from PyQt6.QtWidgets import QApplication
from new_interface import FullscreenCircleApp

if __name__ == "__main__":
    try:
        if getattr(sys, 'frozen', False):
            # If running as an executable (PyInstaller), app_path is the directory of the .exe
            app_path = os.path.dirname(sys.executable)
            # For EXE, void_dir is the same directory as the executable
            void_dir = app_path
            print(f"EXE Mode: Files will be saved directly in the executable's directory.")
        else:
            # If running as a Python script, app_path is the directory of the script
            app_path = os.path.dirname(os.path.abspath(__file__))
            # For script, void_dir is a 'void' subdirectory
            void_dir = os.path.join(app_path, 'void')
            print(f"Script Mode: Files will be saved in the 'void' subdirectory.")

        # Check for command-line arguments
        file_to_open = None
        if len(sys.argv) > 1:
            # Get the first argument (potential file path)
            candidate_file = sys.argv[1]
            # Verify it's a .txt file and exists (or can be created)
            if candidate_file.lower().endswith('.txt'):
                # Convert to absolute path to handle drag-and-drop or relative paths
                candidate_file = os.path.abspath(candidate_file)
                if os.path.exists(candidate_file) or os.path.dirname(candidate_file) == void_dir:
                    file_to_open = candidate_file
                    print(f"Opening specified file: {file_to_open}")
                else:
                    print(f"File {candidate_file} does not exist and is not in void_dir. Defaulting to 0.txt.")
            else:
                print(f"Argument {candidate_file} is not a .txt file. Defaulting to 0.txt.")
        
        # If no valid file was provided, default to 0.txt in void_dir
        if not file_to_open:
            file_to_open = os.path.join(void_dir, '0.txt')
            print(f"No file specified. Defaulting to: {file_to_open}")

        read_dir = os.path.dirname(app_path)
        
        print(f"Working directory: {os.getcwd()}")
        print(f"App path: {app_path}")
        print(f"Void dir (where files are saved): {void_dir}")
        print(f"Active file: {file_to_open}")
        
        app = QApplication(sys.argv)
        # Pass void_dir and the file to open to FullscreenCircleApp
        window = FullscreenCircleApp(read_dir=read_dir, void_dir=void_dir, file_to_open=file_to_open)
        window.show()
        print("Window shown")
        sys.exit(app.exec())
    except Exception as e:
        print(f"Error: {e}")
        input("Press Enter to exit...")

# --- __init__.py ---

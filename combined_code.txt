

# --- build_exe.py ---
# SOLUCI√ìN 1: Script simplificado sin scipy problem√°tico
import os
import datetime
import sys
import PyInstaller.__main__

def build_simple():
    """Versi√≥n simplificada que evita el problema con scipy"""
    timestamp = datetime.datetime.now().strftime('%y-%m-%d_%H-%M-%S')
    exe_name = f'voider-{timestamp}'
    
    base_dir = os.path.dirname(os.path.abspath(__file__))
    build_root = os.path.join(base_dir, 'builds')
    dist_dir = os.path.join(build_root, 'dist')
    work_dir = os.path.join(build_root, 'build')
    spec_dir = build_root
    main_script = os.path.join(base_dir, 'voider.py')
    icon_path = os.path.join(base_dir, 'voider.ico')
    
    os.makedirs(dist_dir, exist_ok=True)
    os.makedirs(work_dir, exist_ok=True)
    os.makedirs(spec_dir, exist_ok=True)
    
    # Argumentos m√≠nimos - SIN scipy que est√° causando problemas
    args = [
        '--clean',
        '--onefile',  # Cambiar a onedir por ahora
        '--windowed',
        main_script,
        f'--name={exe_name}',
        f'--distpath={dist_dir}',
        f'--workpath={work_dir}',
        f'--specpath={spec_dir}',
        
        # Solo los imports esenciales
        '--hidden-import=PyQt6',
        '--hidden-import=PyQt6.QtCore',
        '--hidden-import=PyQt6.QtGui',
        '--hidden-import=PyQt6.QtWidgets',
        '--hidden-import=sounddevice',
        
        # Excluir scipy problem√°tico
        '--exclude-module=scipy',
        '--exclude-module=numpy.distutils',
    ]
    
    if os.path.exists(icon_path):
        args.append(f'--icon={icon_path}')
    
    print(f"üîß Construyendo versi√≥n simplificada: {exe_name}")
    try:
        PyInstaller.__main__.run(args)
        print("‚úÖ ¬°Versi√≥n simplificada completada!")
        return True
    except Exception as e:
        print(f"‚ùå Error en versi√≥n simplificada: {e}")
        return False

def build_with_spec_file():
    """SOLUCI√ìN 2: Crear archivo .spec personalizado"""
    timestamp = datetime.datetime.now().strftime('%y-%m-%d_%H-%M-%S')
    exe_name = f'voider-{timestamp}'
    
    base_dir = os.path.dirname(os.path.abspath(__file__))
    spec_content = f'''# -*- mode: python ; coding: utf-8 -*-

a = Analysis(
    ['voider.py'],
    pathex=['{base_dir.replace(chr(92), chr(92)+chr(92))}'],
    binaries=[],
    datas=[('voider.ico', '.')] if os.path.exists('voider.ico') else [],
    hiddenimports=[
        'PyQt6',
        'PyQt6.QtCore',
        'PyQt6.QtGui', 
        'PyQt6.QtWidgets',
        'sounddevice',
    ],
    hookspath=[],
    runtime_hooks=[],
    excludes=['scipy', 'matplotlib', 'tkinter', 'pygame', 'torch'],
    noarchive=False,
)

pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='{exe_name}',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon='voider.ico' if os.path.exists('voider.ico') else None,
)
'''
    
    spec_file = f'{exe_name}.spec'
    with open(spec_file, 'w') as f:
        f.write(spec_content)
    
    print(f"üìù Archivo .spec creado: {spec_file}")
    print("üîß Ejecuta manualmente: pyinstaller --clean " + spec_file)
    return spec_file

def build_conda_fix():
    """SOLUCI√ìN 3: Versi√≥n para entornos conda/problemas de dependencias"""
    timestamp = datetime.datetime.now().strftime('%y-%m-%d_%H-%M-%S')
    exe_name = f'voider-{timestamp}'
    
    base_dir = os.path.dirname(os.path.abspath(__file__))
    build_root = os.path.join(base_dir, 'builds')
    dist_dir = os.path.join(build_root, 'dist')
    work_dir = os.path.join(build_root, 'build')
    spec_dir = build_root
    main_script = os.path.join(base_dir, 'voider.py')
    
    os.makedirs(dist_dir, exist_ok=True)
    os.makedirs(work_dir, exist_ok=True)
    os.makedirs(spec_dir, exist_ok=True)
    
    args = [
        '--clean',
        '--onedir',
        '--console',  # Temporalmente para ver errores
        main_script,
        f'--name={exe_name}',
        f'--distpath={dist_dir}',
        f'--workpath={work_dir}',
        f'--specpath={spec_dir}',
        '--noupx',  # Desactivar UPX que a veces causa problemas
        '--debug=all',  # M√°s informaci√≥n de debug
    ]
    
    print(f"üîß Construyendo versi√≥n debug: {exe_name}")
    try:
        PyInstaller.__main__.run(args)
        print("‚úÖ ¬°Versi√≥n debug completada!")
        return True
    except Exception as e:
        print(f"‚ùå Error en versi√≥n debug: {e}")
        return False

def main():
    print("üöÄ Iniciando soluciones para PyInstaller...")
    print("=" * 50)
    
    # Informaci√≥n del sistema
    print("üìä Informaci√≥n del sistema:")
    print(f"   Python: {sys.version}")
    print(f"   Directorio: {os.getcwd()}")
    
    try:
        import PyInstaller
        print(f"   PyInstaller: {PyInstaller.__version__}")
    except:
        print("   PyInstaller: No disponible")
    
    try:
        import scipy
        print(f"   SciPy: {scipy.__version__}")
    except:
        print("   SciPy: No disponible")
    
    print("=" * 50)
    
    # Intentar soluciones en orden
    print("\n1Ô∏è‚É£ Intentando versi√≥n simplificada...")
    if build_simple():
        return
    
    print("\n2Ô∏è‚É£ Creando archivo .spec personalizado...")
    spec_file = build_with_spec_file()
    
    print("\n3Ô∏è‚É£ Intentando versi√≥n debug...")
    if build_conda_fix():
        return
    
    print("\n" + "=" * 50)
    print("üîß INSTRUCCIONES MANUALES:")
    print("=" * 50)
    print("Si nada funcion√≥ autom√°ticamente, prueba estos comandos manuales:")
    print()
    print("OPCI√ìN A - Sin scipy:")
    print("pyinstaller --onedir --windowed --clean voider.py --exclude-module=scipy")
    print()
    print("OPCI√ìN B - Solo lo esencial:")
    print("pyinstaller --onedir --console voider.py")
    print()
    print("OPCI√ìN C - Usar el .spec generado:")
    print(f"pyinstaller --clean {spec_file}")
    print()
    print("OPCI√ìN D - Actualizar PyInstaller:")
    print("pip install --upgrade pyinstaller")
    print()
    print("OPCI√ìN E - Crear entorno virtual limpio:")
    print("python -m venv venv_clean")
    print("venv_clean\\Scripts\\activate")
    print("pip install PyQt6 sounddevice pyinstaller")

if __name__ == "__main__":
    main()

# --- controls.py ---
# --- controls.py ---
import random
import os
from files import setup_file_handling, void_line
from tools import clean_text
from PyQt6.QtWidgets import QApplication

def setup_controls(app):
    pass  # Los eventos est√°n en keyPressEvent y returnPressed

def show_random_line_from_zero(app, event=None):
    """Muestra una l√≠nea aleatoria de 0.txt y guarda su √≠ndice para reemplazo."""
    try:
        zero_file_path = app.void_file_path
        print(f"Intentando leer: {zero_file_path}")
        if os.path.exists(zero_file_path):
            with open(zero_file_path, 'r', encoding='utf-8') as f:
                lines = [line.rstrip('\n') for line in f.readlines() if line.strip()]
            if lines:
                app.current_zero_line = random.choice(lines)
                app.current_zero_line_index = lines.index(app.current_zero_line)
                app.entry.setText(app.current_zero_line)
                app.entry.setCursorPosition(0)  # Mover cursor al inicio
                print(f"Random line from 0.txt: {app.current_zero_line}, Index: {app.current_zero_line_index}")
            else:
                print("0.txt est√° vac√≠o.")
                app.entry.clear()
                app.current_zero_line = None
                app.current_zero_line_index = None
        else:
            print("0.txt no existe.")
            app.entry.clear()
            app.current_zero_line = None
            app.current_zero_line_index = None
    except Exception as e:
        print(f"Error en show_random_line_from_zero: {e}")

def show_previous_zero_line(app, event=None):
    """Muestra la l√≠nea previa en 0.txt, con comportamiento circular y contextual."""
    try:
        zero_file_path = app.void_file_path
        print(f"Navegando a l√≠nea previa en: {zero_file_path}")
        if not os.path.exists(zero_file_path):
            print("0.txt no existe.")
            app.entry.clear()
            return

        with open(zero_file_path, 'r', encoding='utf-8') as f:
            lines = [line.rstrip('\n') for line in f.readlines() if line.strip()]
        
        if not lines:
            print("0.txt est√° vac√≠o.")
            app.entry.clear()
            app.current_zero_line_index = None
            app.current_zero_line = None
            return

        if not app.entry.text().strip() and app.last_inserted_index is not None:
            app.current_zero_line_index = app.last_inserted_index
            print(f"Entry vac√≠o, mostrando √∫ltima l√≠nea enviada, Index: {app.current_zero_line_index}")
        elif app.current_zero_line_index is None:
            app.current_zero_line_index = len(lines) - 1
            print(f"Sin √≠ndice actual, empezando desde la √∫ltima l√≠nea, Index: {app.current_zero_line_index}")
        else:
            app.current_zero_line_index = (app.current_zero_line_index - 1) % len(lines)
            print(f"Navegando a l√≠nea previa, Index: {app.current_zero_line_index}")

        app.current_zero_line = lines[app.current_zero_line_index]
        app.entry.setText(app.current_zero_line)
        app.entry.setCursorPosition(0)
        print(f"Previous Line - 0.txt, Index: {app.current_zero_line_index}, Line: {app.current_zero_line}")
    except Exception as e:
        print(f"Error en show_previous_zero_line: {e}")
        app.entry.clear()

def show_next_zero_line(app, event=None):
    """Muestra la l√≠nea siguiente en 0.txt, con comportamiento circular."""
    try:
        zero_file_path = app.void_file_path
        print(f"Navegando a l√≠nea siguiente en: {zero_file_path}")
        if not os.path.exists(zero_file_path):
            print("0.txt no existe.")
            app.entry.clear()
            return

        with open(zero_file_path, 'r', encoding='utf-8') as f:
            lines = [line.rstrip('\n') for line in f.readlines() if line.strip()]
        
        if not lines:
            print("0.txt est√° vac√≠o.")
            app.entry.clear()
            app.current_zero_line_index = None
            app.current_zero_line = None
            return

        if not app.entry.text().strip() and app.last_inserted_index is not None:
            app.current_zero_line_index = (app.last_inserted_index + 1) % len(lines)
            print(f"Entry vac√≠o, mostrando l√≠nea siguiente a la √∫ltima enviada, Index: {app.current_zero_line_index}")
        elif app.current_zero_line_index is None:
            app.current_zero_line_index = 0
            print(f"Sin √≠ndice actual, empezando desde la primera l√≠nea, Index: {app.current_zero_line_index}")
        else:
            app.current_zero_line_index = (app.current_zero_line_index + 1) % len(lines)
            print(f"Navegando a l√≠nea siguiente, Index: {app.current_zero_line_index}")

        app.current_zero_line = lines[app.current_zero_line_index]
        app.entry.setText(app.current_zero_line)
        app.entry.setCursorPosition(0)
        print(f"Next Line - 0.txt, Index: {app.current_zero_line_index}, Line: {app.current_zero_line}")
    except Exception as e:
        print(f"Error en show_next_zero_line: {e}")
        app.entry.clear()

# --- files.py ---
# --- files.py ---
import os
import random
import re

def setup_file_handling(app):
    """Inicializa el manejo de 0.txt en el directorio void."""
    if not os.path.exists(app.void_dir):
        os.makedirs(app.void_dir)
    if not os.path.exists(app.void_file_path):
        with open(app.void_file_path, 'w', encoding='utf-8') as void_file:
            void_file.write('')
    app.current_zero_line = None
    app.current_zero_line_index = None
    app.last_inserted_index = None

def void_line(app, event=None):
    """Procesa la l√≠nea ingresada, formate√°ndola y guard√°ndola en 0.txt."""
    try:
        line = app.entry.text().strip()
        app.entry.clear()
        app.entry.setFocus()

        if line:
            # --- FORMATO ---
            protected = line.replace("...", "<ELLIPSIS>")
            raw_sentences = re.split(r'\.(?=\s|$)', protected)
            formatted_lines = []
            for raw in raw_sentences:
                s = raw.strip()
                if not s:
                    continue
                s = s.replace("<ELLIPSIS>", "...")
                s = s[0].upper() + s[1:] if s else s
                if not s.endswith('.') and not s.endswith('...'):
                    s += '.'
                formatted_lines.append(s)
            formatted_text = '\n'.join(formatted_lines)
            # --- FIN FORMATO ---

            if line.startswith("/"):
                base, ext = os.path.splitext(app.void_file_path)
                if line == "/":
                    num_digits = random.randint(1, 10)
                    random_number = ''.join([str(random.randint(0, 9)) for _ in range(num_digits)])
                    new_file_path = f"{base}_{random_number}{ext}"
                else:
                    new_name = line[1:]
                    new_file_path = os.path.join(app.void_dir, f"{new_name}{ext}")
                if os.path.exists(new_file_path):
                    with open(app.void_file_path, 'r', encoding='utf-8') as void_file:
                        content_to_append = void_file.read()
                    with open(new_file_path, 'a', encoding='utf-8') as target_file:
                        target_file.write(content_to_append)
                    with open(app.void_file_path, 'w', encoding='utf-8') as void_file:
                        void_file.write('')
                else:
                    os.rename(app.void_file_path, new_file_path)
                    with open(app.void_file_path, 'w', encoding='utf-8') as void_file:
                        void_file.write('')
                app.last_inserted_index = None
                app.current_zero_line_index = None
            else:
                with open(app.void_file_path, 'r', encoding='utf-8') as f:
                    lines = f.readlines()

                if hasattr(app, 'current_zero_line_index') and app.current_zero_line_index is not None:
                    if app.current_zero_line_index < len(lines):
                        lines[app.current_zero_line_index] = formatted_text + '\n'
                        app.last_inserted_index = app.current_zero_line_index
                    app.current_zero_line_index = None
                    app.current_zero_line = None
                else:
                    insert_index = (app.last_inserted_index + 1) if hasattr(app, 'last_inserted_index') and app.last_inserted_index is not None else len(lines)
                    lines.insert(insert_index, formatted_text + '\n')
                    app.last_inserted_index = insert_index
                    app.current_zero_line_index = None

                with open(app.void_file_path, 'w', encoding='utf-8') as f:
                    f.writelines(lines)
                    f.flush()
                    os.fsync(f.fileno())
        else:
            app.current_zero_line_index = None
            app.current_zero_line = None

        return 'break'

    except Exception as e:
        print(f"Error en void_line: {e}")
        app.entry.clear()
        app.entry.setFocus()
        return 'break'

# --- new_interface.py ---
# --- new_interface.py ---
import os
import sys
import numpy as np
from PyQt6.QtWidgets import QApplication, QMainWindow, QLineEdit, QLabel, QWidget
from PyQt6.QtGui import QColor, QPainter, QFont, QCursor, QPen, QPixmap, QImage
from PyQt6.QtCore import Qt, QTimer
from files import setup_file_handling, void_line
from controls import setup_controls, show_random_line_from_zero, show_previous_zero_line, show_next_zero_line
from noise_controls import NoiseController

class CustomLineEdit(QLineEdit):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent

    def keyPressEvent(self, event):
        key = event.key()
        modifiers = event.modifiers()
        if key == Qt.Key.Key_0:
            print("Tecla 0 detectada en QLineEdit, ejecutando show_random_line_from_zero")
            self.parent.last_inserted_index = None
            show_random_line_from_zero(self.parent, event)
            event.accept()
        elif (key == Qt.Key.Key_Up or key == Qt.Key.Key_Down) and modifiers == Qt.KeyboardModifier.ControlModifier:
            self.parent.keyPressEvent(event)
        else:
            super().keyPressEvent(event)

class CircleBackground(QWidget):
    def __init__(self, parent=None, center_x=0, center_y=0, radius=0):
        super().__init__(parent)
        self.center_x = center_x
        self.center_y = center_y
        self.radius = radius
        self.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        pen = QPen(QColor("white"), 10)
        painter.setPen(pen)
        painter.setBrush(Qt.BrushStyle.NoBrush)
        painter.drawEllipse(
            self.center_x - self.radius,
            self.center_y - self.radius,
            self.radius * 2,
            self.radius * 2
        )

    def resizeEvent(self, event):
        self.resize(self.parent().size())

class NoiseOverlay(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.noise_pixmap = None
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.generate_noise)
        self.timer.start(100)

    def generate_noise(self):
        block_size = 2
        w, h = self.width(), self.height()
        h_blocks, w_blocks = h // block_size, w // block_size
        noise_rgb = np.random.randint(0, 256, (h_blocks, w_blocks, 3), dtype=np.uint8)
        image = QImage(noise_rgb.data, w_blocks, h_blocks, QImage.Format.Format_RGB888)
        image = image.scaled(w, h, Qt.AspectRatioMode.IgnoreAspectRatio, Qt.TransformationMode.FastTransformation)
        self.noise_pixmap = QPixmap.fromImage(image)
        self.update()

    def paintEvent(self, event):
        if self.noise_pixmap:
            painter = QPainter(self)
            painter.setOpacity(0.1)
            painter.drawPixmap(0, 0, self.noise_pixmap)

class FullscreenCircleApp(QMainWindow):
    def __init__(self, read_dir=None, void_dir=None):
        super().__init__()
        self.opacity = 1.0
        self.read_dir = read_dir or os.path.dirname(os.path.abspath(__file__))
        self.void_dir = void_dir or os.path.join(self.read_dir, 'void')
        self.setWindowTitle("Voider")
        self.setWindowFlag(Qt.WindowType.FramelessWindowHint)
        self.setCursor(QCursor(Qt.CursorShape.BlankCursor))
        self.setStyleSheet("background-color: black;")

        self.entry = CustomLineEdit(self)
        self.entry.setFont(QFont("Consolas", 11))
        self.entry.setStyleSheet("""
            QLineEdit {
                background-color: black;
                color: white;
                border: none;
                qproperty-alignment: AlignCenter;
                selection-background-color: white;
                selection-color: black;
            }
        """)
        self.entry.setFocus()
        self.entry.returnPressed.connect(lambda: void_line(self))

        self.loading = QLabel("Loading potentiality", self)
        self.loading.setFont(QFont("Consolas", 11))
        self.loading.setStyleSheet("color: white; background-color: black;")
        self.loading.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.loading.resize(300, 100)
        self.loading.hide()

        self.noise_controller = NoiseController(
            block_size=1024, volume=0.3, noise_type='brown',
            bitcrush={'bit_depth': 10, 'sample_rate_factor': 0.7},
            lfo_min_freq=0.03, lfo_max_freq=0.1, glitch_prob=0.005, cutoff_freq=2500
        )

        self.setup_voider_logic()
        self.init_ui()

    def setup_voider_logic(self):
        os.makedirs(self.void_dir, exist_ok=True)
        self.void_file_path = os.path.join(self.void_dir, '0.txt')
        print(f"void_file_path inicializado: {self.void_file_path}")
        self.current_zero_line = None
        self.current_zero_line_index = None
        self.last_inserted_index = None
        setup_file_handling(self)
        setup_controls(self)

    def init_ui(self):
        print("Initializing UI")
        self.showFullScreen()
        screen = self.screen().availableGeometry()
        self.center_x = screen.width() // 2
        self.center_y = screen.height() // 2
        self.radius = min(screen.width(), screen.height()) // 2 - 35
        entry_width = self.radius * 2 - 40
        self.entry.setFixedWidth(entry_width)
        self.entry.move(self.center_x - entry_width // 2,
                        self.center_y - self.entry.height() // 2)
        self.loading.move(self.center_x - 150, self.center_y - 50)
        self.loading.show()
        QTimer.singleShot(1500, self.loading.deleteLater)
        self.circle_background = CircleBackground(self, self.center_x, self.center_y, self.radius)
        self.circle_background.resize(self.size())
        self.circle_background.show()
        self.noise_overlay = NoiseOverlay(self)
        self.noise_overlay.resize(self.size())
        self.noise_overlay.show()

    def resizeEvent(self, event):
        super().resizeEvent(event)
        if hasattr(self, 'noise_overlay'):
            self.noise_overlay.resize(self.size())
        if hasattr(self, 'circle_background'):
            self.circle_background.resize(self.size())

    def keyPressEvent(self, event):
        key = event.key()
        modifiers = event.modifiers()
        print(f"Tecla en ventana: {key}, Modificadores: {modifiers}")

        if key == Qt.Key.Key_Escape:
            self.noise_controller.stop()
            self.close()
        elif key == Qt.Key.Key_Up and modifiers == Qt.KeyboardModifier.ControlModifier:
            self.increase_opacity()
        elif key == Qt.Key.Key_Down and modifiers == Qt.KeyboardModifier.ControlModifier:
            self.decrease_opacity()
        elif key == Qt.Key.Key_Up:
            show_previous_zero_line(self)
        elif key == Qt.Key.Key_Down:
            show_next_zero_line(self)

    def increase_opacity(self):
        self.opacity = min(1.0, self.opacity + 0.1)
        self.setWindowOpacity(self.opacity)

    def decrease_opacity(self):
        self.opacity = max(0.0, self.opacity - 0.1)
        self.setWindowOpacity(self.opacity)

if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = FullscreenCircleApp()
    window.show()
    sys.exit(app.exec())

# --- noise_controls.py ---
# --- noise_controls.py ---
import numpy as np
import sounddevice as sd
from PyQt6.QtCore import QTimer

class NoiseController:
    def __init__(self, sample_rate=44100, block_size=1024, volume=0.01, noise_type='brown',
                 bitcrush={'bit_depth': 8, 'sample_rate_factor': 0.6},
                 lfo_min_freq=0.01, lfo_max_freq=0.03, glitch_prob=0.001, cutoff_freq=300):
        self.sample_rate = sample_rate
        self.block_size = block_size
        self.volume = volume
        self.noise_type = noise_type
        self.bitcrush = bitcrush
        self.lfo_min_freq = lfo_min_freq
        self.lfo_max_freq = lfo_max_freq
        self.glitch_prob = glitch_prob
        self.cutoff_freq = cutoff_freq
        self.stream = None
        self.timer = None
        self.lfo_state = 0

        try:
            self.stream = sd.OutputStream(
                samplerate=sample_rate,
                blocksize=block_size,
                channels=2,
                callback=self.audio_callback
            )
            self.stream.start()
            self.start_lfo_generator()
            print(f"NoiseController: {self.noise_type.capitalize()} subtle meditative noise started.")
        except Exception as e:
            print(f"NoiseController: Error initializing audio: {str(e)}")

    def lowpass_filter(self, data, cutoff, alpha=0.1):
        """
        Filtro pasa bajos simple usando un filtro de media m√≥vil exponencial.
        `alpha` controla la suavidad (m√°s bajo = m√°s suave).
        """
        filtered = np.zeros_like(data)
        filtered[0] = data[0]
        for i in range(1, len(data)):
            filtered[i] = alpha * data[i] + (1 - alpha) * filtered[i - 1]
        return filtered

    def apply_bitcrush(self, noise, bit_depth=16, sample_rate_factor=1.0):
        original_length = len(noise)
        if sample_rate_factor < 1.0:
            new_length = int(original_length * sample_rate_factor)
            new_length = max(1, new_length)
            indices = np.linspace(0, original_length - 1, new_length).astype(int)
            noise = noise[indices]
            noise = np.tile(noise, (original_length // len(noise) + 1))[:original_length]
        if bit_depth < 16:
            max_val = 2 ** (bit_depth - 1) - 1
            noise = np.round(noise / 32767 * max_val) / max_val * 32767
        return noise.astype(np.int16)

    def generate_variable_lfo(self, t, min_freq, max_freq):
        n_points = 4
        rand_freqs = np.random.uniform(min_freq, max_freq, n_points)
        rand_phases = np.random.uniform(0, 2 * np.pi, n_points)
        key_times = np.linspace(0, self.block_size / self.sample_rate, n_points)
        freqs = np.interp(t, key_times, rand_freqs)
        phases = np.interp(t, key_times, rand_phases)
        return 0.97 + 0.03 * np.sin(2 * np.pi * freqs * t + phases)

    def audio_callback(self, outdata, frames, time, status):
        if status:
            print(f"Audio callback status: {status}")
        if frames != self.block_size:
            return

        if self.noise_type == 'brown':
            white = np.random.uniform(-1, 1, frames)
            brown = np.cumsum(white)
            noise = brown / np.max(np.abs(brown)) * 0.8
        elif self.noise_type == 'white':
            noise = np.random.uniform(-1, 1, frames)
        elif self.noise_type == 'pink':
            white = np.random.uniform(-1, 1, frames)
            pink = np.cumsum(white) / np.arange(1, frames + 1) ** 0.5
            noise = pink / np.max(np.abs(pink)) * 0.8
        else:
            noise = np.zeros(frames)

        noise = self.lowpass_filter(noise, cutoff=self.cutoff_freq)

        t = np.linspace(self.lfo_state, self.lfo_state + frames / self.sample_rate, frames)
        self.lfo_state += frames / self.sample_rate
        noise *= self.generate_variable_lfo(t, self.lfo_min_freq, self.lfo_max_freq)

        if np.random.rand() < 0.25:  # reducir cantidad de glitches
            glitch_mask = np.random.random(frames) < self.glitch_prob
            noise[glitch_mask] *= np.random.uniform(0.9, 1.1, glitch_mask.sum())

        if self.bitcrush:
            bit_depth = self.bitcrush.get('bit_depth', 8)
            sample_rate_factor = self.bitcrush.get('sample_rate_factor', 0.6)
            noise = (noise * 32767).astype(np.float32)
            noise = self.apply_bitcrush(noise, bit_depth, sample_rate_factor)

        noise = noise / np.max(np.abs(noise)) * 0.1 * self.volume
        stereo_noise = np.repeat(noise[:, np.newaxis], 2, axis=1)
        outdata[:] = stereo_noise

    def start_lfo_generator(self):
        self.timer = QTimer()
        self.timer.timeout.connect(lambda: None)
        self.timer.start(100)

    def stop(self):
        if self.stream:
            self.stream.stop()
            self.stream.close()
        if self.timer:
            self.timer.stop()
        print("NoiseController: Stopped")

    def set_volume(self, volume):
        self.volume = max(0.0, min(1.0, volume))
        print(f"NoiseController: Volume set to {self.volume:.2f}")

    def set_noise_type(self, noise_type):
        self.noise_type = noise_type
        print(f"NoiseController: Noise type set to {self.noise_type}")

    def set_bitcrush(self, bitcrush):
        self.bitcrush = bitcrush
        print(f"NoiseController: Bitcrush set to {self.bitcrush}")

    def set_lfo_freq(self, min_freq, max_freq):
        self.lfo_min_freq = min_freq
        self.lfo_max_freq = max_freq
        print(f"NoiseController: LFO freq range set to {min_freq:.2f}-{max_freq:.2f} Hz")

    def set_glitch_prob(self, prob):
        self.glitch_prob = max(0.0, min(0.1, prob))
        print(f"NoiseController: Glitch probability set to {self.glitch_prob:.4f}")

    def set_cutoff_freq(self, cutoff):
        self.cutoff_freq = max(50, min(8000, cutoff))
        print(f"NoiseController: Cutoff frequency set to {self.cutoff_freq} Hz")


# --- tools.py ---
# --- tools.py ---
def clean_text(text):
    return text  # Devolver texto sin cambios

def close_program(app, event=None):
    app.close()

def show_cursor(app, event=None):
    app.entry.setCursorVisible(True)

# --- voider.py ---
# --- voider.py ---
import os
import sys
from PyQt6.QtWidgets import QApplication
from new_interface import FullscreenCircleApp

if __name__ == "__main__":
    try:
        if getattr(sys, 'frozen', False):
            app_path = os.path.dirname(sys.executable)
        else:
            app_path = os.path.dirname(os.path.abspath(__file__))  # V01DER directory
        read_dir = os.path.dirname(app_path)  # Z:\programming\Voider\V2
        void_dir = os.path.join(app_path, 'void')  # Z:\programming\Voider\V2\V01DER\void
        print(f"Working directory: {os.getcwd()}")
        print(f"App path: {app_path}")
        print(f"Void dir: {void_dir}")
        if not os.path.exists(void_dir):
            print(f"Creating: {void_dir}")
            try:
                os.makedirs(void_dir)
            except Exception as e:
                print(f"Error creating void folder: {e}")
        else:
            print(f"Void folder exists: {void_dir}")
        app = QApplication(sys.argv)
        window = FullscreenCircleApp(read_dir=read_dir, void_dir=void_dir)
        window.show()
        print("Window shown")
        sys.exit(app.exec())
    except Exception as e:
        print(f"Error: {e}")
        input("Press Enter to exit...")

# --- __init__.py ---



# --- build_exe.py ---
# SOLUCI√ìN 1: Script simplificado sin scipy problem√°tico
import os
import datetime
import sys
import PyInstaller.__main__

def build_simple():
    """Versi√≥n simplificada que evita el problema con scipy"""
    timestamp = datetime.datetime.now().strftime('%y-%m-%d_%H-%M-%S')
    exe_name = f'voider-{timestamp}'
    
    base_dir = os.path.dirname(os.path.abspath(__file__))
    build_root = os.path.join(base_dir, 'builds')
    dist_dir = os.path.join(build_root, 'dist')
    work_dir = os.path.join(build_root, 'build')
    spec_dir = build_root
    main_script = os.path.join(base_dir, 'voider.py')
    icon_path = os.path.join(base_dir, 'voider.ico')
    
    os.makedirs(dist_dir, exist_ok=True)
    os.makedirs(work_dir, exist_ok=True)
    os.makedirs(spec_dir, exist_ok=True)
    
    # Argumentos m√≠nimos - SIN scipy que est√° causando problemas
    args = [
        '--clean',
        '--onefile',  # Cambiar a onedir por ahora
        '--windowed',
        main_script,
        f'--name={exe_name}',
        f'--distpath={dist_dir}',
        f'--workpath={work_dir}',
        f'--specpath={spec_dir}',
        
        # Solo los imports esenciales
        '--hidden-import=PyQt6',
        '--hidden-import=PyQt6.QtCore',
        '--hidden-import=PyQt6.QtGui',
        '--hidden-import=PyQt6.QtWidgets',
        '--hidden-import=sounddevice',
        
        # Excluir scipy problem√°tico
        '--exclude-module=scipy',
        '--exclude-module=numpy.distutils',
    ]
    
    if os.path.exists(icon_path):
        args.append(f'--icon={icon_path}')
    
    print(f"üîß Construyendo versi√≥n simplificada: {exe_name}")
    try:
        PyInstaller.__main__.run(args)
        print("‚úÖ ¬°Versi√≥n simplificada completada!")
        return True
    except Exception as e:
        print(f"‚ùå Error en versi√≥n simplificada: {e}")
        return False

def build_with_spec_file():
    """SOLUCI√ìN 2: Crear archivo .spec personalizado"""
    timestamp = datetime.datetime.now().strftime('%y-%m-%d_%H-%M-%S')
    exe_name = f'voider-{timestamp}'
    
    base_dir = os.path.dirname(os.path.abspath(__file__))
    spec_content = f'''# -*- mode: python ; coding: utf-8 -*-

a = Analysis(
    ['voider.py'],
    pathex=['{base_dir.replace(chr(92), chr(92)+chr(92))}'],
    binaries=[],
    datas=[('voider.ico', '.')] if os.path.exists('voider.ico') else [],
    hiddenimports=[
        'PyQt6',
        'PyQt6.QtCore',
        'PyQt6.QtGui', 
        'PyQt6.QtWidgets',
        'sounddevice',
    ],
    hookspath=[],
    runtime_hooks=[],
    excludes=['scipy', 'matplotlib', 'tkinter', 'pygame', 'torch'],
    noarchive=False,
)

pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='{exe_name}',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon='voider.ico' if os.path.exists('voider.ico') else None,
)
'''
    
    spec_file = f'{exe_name}.spec'
    with open(spec_file, 'w') as f:
        f.write(spec_content)
    
    print(f"üìù Archivo .spec creado: {spec_file}")
    print("üîß Ejecuta manualmente: pyinstaller --clean " + spec_file)
    return spec_file

def build_conda_fix():
    """SOLUCI√ìN 3: Versi√≥n para entornos conda/problemas de dependencias"""
    timestamp = datetime.datetime.now().strftime('%y-%m-%d_%H-%M-%S')
    exe_name = f'voider-{timestamp}'
    
    base_dir = os.path.dirname(os.path.abspath(__file__))
    build_root = os.path.join(base_dir, 'builds')
    dist_dir = os.path.join(build_root, 'dist')
    work_dir = os.path.join(build_root, 'build')
    spec_dir = build_root
    main_script = os.path.join(base_dir, 'voider.py')
    
    os.makedirs(dist_dir, exist_ok=True)
    os.makedirs(work_dir, exist_ok=True)
    os.makedirs(spec_dir, exist_ok=True)
    
    args = [
        '--clean',
        '--onedir',
        '--console',  # Temporalmente para ver errores
        main_script,
        f'--name={exe_name}',
        f'--distpath={dist_dir}',
        f'--workpath={work_dir}',
        f'--specpath={spec_dir}',
        '--noupx',  # Desactivar UPX que a veces causa problemas
        '--debug=all',  # M√°s informaci√≥n de debug
    ]
    
    print(f"üîß Construyendo versi√≥n debug: {exe_name}")
    try:
        PyInstaller.__main__.run(args)
        print("‚úÖ ¬°Versi√≥n debug completada!")
        return True
    except Exception as e:
        print(f"‚ùå Error en versi√≥n debug: {e}")
        return False

def main():
    print("üöÄ Iniciando soluciones para PyInstaller...")
    print("=" * 50)
    
    # Informaci√≥n del sistema
    print("üìä Informaci√≥n del sistema:")
    print(f"   Python: {sys.version}")
    print(f"   Directorio: {os.getcwd()}")
    
    try:
        import PyInstaller
        print(f"   PyInstaller: {PyInstaller.__version__}")
    except:
        print("   PyInstaller: No disponible")
    
    try:
        import scipy
        print(f"   SciPy: {scipy.__version__}")
    except:
        print("   SciPy: No disponible")
    
    print("=" * 50)
    
    # Intentar soluciones en orden
    print("\n1Ô∏è‚É£ Intentando versi√≥n simplificada...")
    if build_simple():
        return
    
    print("\n2Ô∏è‚É£ Creando archivo .spec personalizado...")
    spec_file = build_with_spec_file()
    
    print("\n3Ô∏è‚É£ Intentando versi√≥n debug...")
    if build_conda_fix():
        return
    
    print("\n" + "=" * 50)
    print("üîß INSTRUCCIONES MANUALES:")
    print("=" * 50)
    print("Si nada funcion√≥ autom√°ticamente, prueba estos comandos manuales:")
    print()
    print("OPCI√ìN A - Sin scipy:")
    print("pyinstaller --onedir --windowed --clean voider.py --exclude-module=scipy")
    print()
    print("OPCI√ìN B - Solo lo esencial:")
    print("pyinstaller --onedir --console voider.py")
    print()
    print("OPCI√ìN C - Usar el .spec generado:")
    print(f"pyinstaller --clean {spec_file}")
    print()
    print("OPCI√ìN D - Actualizar PyInstaller:")
    print("pip install --upgrade pyinstaller")
    print()
    print("OPCI√ìN E - Crear entorno virtual limpio:")
    print("python -m venv venv_clean")
    print("venv_clean\\Scripts\\activate")
    print("pip install PyQt6 sounddevice pyinstaller")

if __name__ == "__main__":
    main()

# --- circular_view.py ---
import math
from PyQt6.QtWidgets import QWidget, QLineEdit
from PyQt6.QtCore import Qt, QPropertyAnimation, pyqtProperty, QEasingCurve, pyqtSignal
from PyQt6.QtGui import QPainter, QFontMetrics, QFont, QKeyEvent

class CircularView(QWidget):
    line_saved = pyqtSignal()
    
    def __init__(self, ring, parent=None):
        super().__init__(parent)
        self.ring = ring
        self._offset = 0.0
        self.line_height = 38
        
        self.max_alpha = 1.0
        self.min_alpha = 0.0
        
        self.circle_radius = 0
        self.current_animation = None
        self.edit_mode = False
        
        # Crear el editor
        self.editor = CustomLineEdit(self)
        self.editor.setFont(QFont("Consolas", 11))
        self.editor.setStyleSheet("""
            QLineEdit {
                background-color: black;
                color: white;
                border: none;
                qproperty-alignment: AlignCenter;
                selection-background-color: white;
                selection-color: black;
            }
        """)
        self.editor.hide()
        self.editor.returnPressed.connect(self.save_edit)
        
        self.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)

    @pyqtProperty(float)
    def offset(self):
        return self._offset

    @offset.setter
    def offset(self, value):
        self._offset = value
        self.update()

    def animate_move(self, delta):
        if self.edit_mode:
            return
            
        if self.current_animation and self.current_animation.state() == QPropertyAnimation.State.Running:
            return
        
        anim = QPropertyAnimation(self, b"offset")
        anim.setDuration(220)
        anim.setEasingCurve(QEasingCurve.Type.OutQuad)
        anim.setStartValue(self._offset)
        anim.setEndValue(self._offset - delta)
        
        def on_finished():
            self.ring.move(delta)
            self._offset = 0.0
            self.update()
            self.current_animation = None
        
        anim.finished.connect(on_finished)
        anim.start()
        self.current_animation = anim

    def enter_edit_mode(self):
        self.edit_mode = True
        
        center_y = self.height() // 2
        editor_width = min(self.width() - 100, 800)
        self.editor.setFixedWidth(editor_width)
        self.editor.move((self.width() - editor_width) // 2, 
                         center_y - self.editor.height() // 2)
        
        current_text = self.ring.current()
        self.editor.setText(current_text)
        self.editor.selectAll()
        self.editor.show()
        self.editor.setFocus()
        
        self.update()

    def save_edit(self):
        new_text = self.editor.text().strip()
        
        if new_text:
            self.ring.lines[self.ring.index] = new_text
            print(f"‚úÖ L√≠nea actualizada: {new_text}")
            self.line_saved.emit()
        
        self.exit_edit_mode()

    def cancel_edit(self):
        self.exit_edit_mode()

    def exit_edit_mode(self):
        self.edit_mode = False
        self.editor.hide()
        self.setFocus()
        self.update()

    def calculate_alpha(self, distance_from_center_px):
        # 1. Distancia en unidades de l√≠nea
        dist = distance_from_center_px / self.line_height
        
        # 2. Funci√≥n de Cauchy / Racional
        # El '+ 1' asegura que en el centro (dist=0) el alpha sea 1.0
        # El '1.5' es el factor de ca√≠da. 
        # Si quer√©s que el degradado sea M√ÅS LARGO todav√≠a, baj√° el 1.5 a 1.0 o 0.8
        alpha = 1.0 / (1.0 + 1.5 * (dist ** 2))
        
        # Ajustamos el m√≠nimo para que no desaparezcan tan r√°pido
        return max(0.02, min(self.max_alpha, alpha))

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.TextAntialiasing)
        fm = QFontMetrics(self.font())

        w = self.width()
        h = self.height()
        center_y = h // 2
        
        if self.edit_mode:
            painter.setOpacity(0.2)
            text = self.ring.current()
            text_rect = fm.boundingRect(0, 0, w, 1000, Qt.AlignmentFlag.AlignCenter, text)
            y = int(center_y - text_rect.height() / 2)
            painter.drawText(0, y, w, text_rect.height(),
                            Qt.AlignmentFlag.AlignCenter | Qt.TextFlag.TextWordWrap,
                            text)
        else:
            # Renderizar suficientes l√≠neas
            if self.circle_radius > 0:
                max_lines = int(self.circle_radius / self.line_height) + 3
            else:
                max_lines = 20
            
            for i in range(-max_lines, max_lines + 1):
                # Calculamos la posici√≥n base con el offset de la animaci√≥n
                y_pos = center_y + (i + self._offset) * self.line_height
                
                text = self.ring.get(i)
                text_rect = fm.boundingRect(0, 0, w, 1000, Qt.AlignmentFlag.AlignCenter, text)
                
                # Coordenada Y donde se dibuja el texto
                draw_y = int(y_pos - text_rect.height() / 2)
                
                # La distancia al centro la medimos desde el centro de la l√≠nea
                distance_from_center = abs(y_pos - center_y)
                
                # Calcular alpha arm√≥nico
                alpha = self.calculate_alpha(distance_from_center)
                
                if alpha < 0.01:
                    continue
                
                painter.setOpacity(alpha)
                painter.drawText(0, draw_y, w, text_rect.height(),
                                Qt.AlignmentFlag.AlignCenter | Qt.TextFlag.TextWordWrap,
                                text)

    def resizeEvent(self, event):
        super().resizeEvent(event)
        screen_width = self.width()
        screen_height = self.height()
        self.circle_radius = min(screen_width, screen_height) // 2 - 35
        
        if self.edit_mode:
            center_y = self.height() // 2
            editor_width = min(self.width() - 100, 800)
            self.editor.setFixedWidth(editor_width)
            self.editor.move((self.width() - editor_width) // 2, 
                             center_y - self.editor.height() // 2)
        self.update()


class CustomLineEdit(QLineEdit):
    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            self.returnPressed.emit()
            event.accept()
        else:
            super().keyPressEvent(event)

# --- combined_code.py ---
import os

output_file = "combined_code.txt"
excluded_files = {
    "build_installer.py",
    "combined_py.py",
    "interface.py",
    "nuitka_build_installer.py",
    "realtime_effects.py",
    "test.py",
}

included_files = []

with open(output_file, "w", encoding="utf-8") as outfile:
    for file in os.listdir("."):
        if file.endswith(".py") and file not in excluded_files:
            included_files.append(file)
            with open(file, "r", encoding="utf-8") as infile:
                outfile.write(f"\n\n# --- {file} ---\n")    
                outfile.write(infile.read())

print(f"‚úÖ Combined .py files into '{output_file}'")
print("üóÇÔ∏è Archivos incluidos:")
for f in included_files:
    print(f" - {f}")


# --- controls.py ---
# --- controls.py ---
import random
import os

def setup_controls(app):
    """Configura los controles de la aplicaci√≥n."""
    print("Configurando controles...")
    # Initialize navigation state
    app.first_up_after_submission = False  # Tracks if next Up press is first after submission

def show_random_line_from_current_file(app, event=None):
    """Muestra una l√≠nea aleatoria del archivo activo, excluyendo la l√≠nea actualmente mostrada."""
    try:
        if os.path.exists(app.current_file_path):
            with open(app.current_file_path, 'r', encoding='utf-8') as f:
                lines = [line.strip() for line in f.readlines() if line.strip()]
            
            if not lines:
                print(f"El archivo {os.path.basename(app.current_file_path)} est√° vac√≠o.")
                app.current_active_line = None
                app.current_active_line_index = None
                app.first_up_after_submission = False
                app.entry.clear()
                return
            
            # Exclude current line if it exists and there are other options
            current_line = app.current_active_line.strip() if app.current_active_line else None
            available_lines = [line for line in lines if line != current_line] if current_line and len(lines) > 1 else lines
            
            if available_lines:
                random_line = random.choice(available_lines)
                app.current_active_line = random_line
                with open(app.current_file_path, 'r', encoding='utf-8') as f:
                    all_lines = f.readlines()
                    for i, line in enumerate(all_lines):
                        if line.strip() == random_line:
                            app.current_active_line_index = i
                            break
                app.entry.setText(random_line)
                app.entry.setCursorPosition(0)
                app.first_up_after_submission = False  # Reset navigation state
                print(f"L√≠nea aleatoria mostrada del archivo activo: {random_line}")
            else:
                print(f"Solo hay una l√≠nea disponible en {os.path.basename(app.current_file_path)}.")
                app.entry.setText(lines[0])  # Fallback to the only line
                app.entry.setCursorPosition(0)
                app.current_active_line = lines[0]
                app.current_active_line_index = lines.index(lines[0])
                app.first_up_after_submission = False
        else:
            print(f"El archivo {os.path.basename(app.current_file_path)} no existe.")
            app.current_active_line = None
            app.current_active_line_index = None
            app.first_up_after_submission = False
            app.entry.clear()
    except Exception as e:
        print(f"Error al mostrar l√≠nea aleatoria del archivo activo: {e}")
        app.current_active_line = None
        app.current_active_line_index = None
        app.first_up_after_submission = False
        app.entry.clear()

def show_random_line_from_random_file(app, event=None):
    """Muestra una l√≠nea aleatoria de un archivo .txt aleatorio, excluyendo el archivo activo."""
    try:
        if not app.txt_files:
            print("No hay archivos .txt disponibles para seleccionar.")
            app.current_active_line = None
            app.current_active_line_index = None
            app.first_up_after_submission = False
            app.entry.clear()
            return
        
        # Exclude current file if there are other options
        available_files = [f for f in app.txt_files if f != app.current_file_path] if len(app.txt_files) > 1 else app.txt_files
        random_file = random.choice(available_files)
        app.switch_to_file(random_file)
        
        with open(random_file, 'r', encoding='utf-8') as f:
            lines = [line.strip() for line in f.readlines() if line.strip()]
        
        if lines:
            random_line = random.choice(lines)
            app.current_active_line = random_line
            with open(random_file, 'r', encoding='utf-8') as f:
                all_lines = f.readlines()
                for i, line in enumerate(all_lines):
                    if line.strip() == random_line:
                        app.current_active_line_index = i
                        break
            app.entry.setText(random_line)
            app.entry.setCursorPosition(0)
            app.first_up_after_submission = False  # Reset navigation state
            print(f"L√≠nea aleatoria mostrada del archivo {os.path.basename(random_file)}: {random_line}")
        else:
            print(f"El archivo {os.path.basename(random_file)} est√° vac√≠o.")
            app.current_active_line = None
            app.current_active_line_index = None
            app.first_up_after_submission = False
            app.entry.clear()
    except Exception as e:
        print(f"Error al mostrar l√≠nea aleatoria de archivo aleatorio: {e}")
        app.current_active_line = None
        app.current_active_line_index = None
        app.first_up_after_submission = False
        app.entry.clear()

def show_previous_current_file_line(app, event=None):
    """Muestra la l√≠nea anterior en el archivo activo, con l√≥gica especial para la primera pulsaci√≥n y navegaci√≥n circular."""
    try:
        if os.path.exists(app.current_file_path):
            with open(app.current_file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            
            if not lines:
                print(f"El archivo {os.path.basename(app.current_file_path)} est√° vac√≠o.")
                app.current_active_line = None
                app.current_active_line_index = None
                app.first_up_after_submission = False
                app.entry.clear()
                return
            
            # If first Up press after submission, show last inserted line
            if app.first_up_after_submission and hasattr(app, 'last_inserted_index') and app.last_inserted_index is not None:
                if app.last_inserted_index < len(lines) and lines[app.last_inserted_index].strip():
                    app.current_active_line = lines[app.last_inserted_index].strip()
                    app.current_active_line_index = app.last_inserted_index  # Set index for next navigation
                    app.entry.setText(app.current_active_line)
                    app.entry.setCursorPosition(0)
                    app.first_up_after_submission = False  # Allow normal navigation next time
                    print(f"Primera flecha arriba: Mostrando √∫ltima l√≠nea enviada: {app.current_active_line}")
                    return
            
            # Normal navigation: Find previous non-empty line with looping
            current_index = app.current_active_line_index if app.current_active_line_index is not None else len(lines)
            new_index = current_index - 1
            
            # If at start, loop to last non-empty line
            if new_index < 0:
                new_index = len(lines) - 1
                while new_index >= 0:
                    if lines[new_index].strip():
                        app.current_active_line_index = new_index
                        app.current_active_line = lines[new_index].strip()
                        app.entry.setText(app.current_active_line)
                        app.entry.setCursorPosition(0)
                        app.first_up_after_submission = False
                        print(f"Loop a √∫ltima l√≠nea: {app.current_active_line}")
                        return
                    new_index -= 1
            
            # Find previous non-empty line
            while new_index >= 0:
                if lines[new_index].strip():
                    app.current_active_line_index = new_index
                    app.current_active_line = lines[new_index].strip()
                    app.entry.setText(app.current_active_line)
                    app.entry.setCursorPosition(0)
                    app.first_up_after_submission = False
                    print(f"L√≠nea anterior mostrada: {app.current_active_line}")
                    return
                new_index -= 1
            
            # If no previous non-empty line, loop to last non-empty line
            new_index = len(lines) - 1
            while new_index >= 0:
                if lines[new_index].strip():
                    app.current_active_line_index = new_index
                    app.current_active_line = lines[new_index].strip()
                    app.entry.setText(app.current_active_line)
                    app.entry.setCursorPosition(0)
                    app.first_up_after_submission = False
                    print(f"Loop a √∫ltima l√≠nea: {app.current_active_line}")
                    return
                new_index -= 1
            
            print("No hay l√≠neas no vac√≠as en el archivo.")
            app.current_active_line = None
            app.current_active_line_index = None
            app.first_up_after_submission = False
            app.entry.clear()
        else:
            print(f"El archivo {os.path.basename(app.current_file_path)} no existe.")
            app.current_active_line = None
            app.current_active_line_index = None
            app.first_up_after_submission = False
            app.entry.clear()
    except Exception as e:
        print(f"Error al mostrar l√≠nea anterior: {e}")
        app.current_active_line = None
        app.current_active_line_index = None
        app.first_up_after_submission = False
        app.entry.clear()

def show_next_current_file_line(app, event=None):
    """Muestra la l√≠nea siguiente en el archivo activo, con navegaci√≥n circular."""
    try:
        if os.path.exists(app.current_file_path):
            with open(app.current_file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            
            if not lines:
                print(f"El archivo {os.path.basename(app.current_file_path)} est√° vac√≠o.")
                app.current_active_line = None
                app.current_active_line_index = None
                app.first_up_after_submission = False
                app.entry.clear()
                return
            
            # If index is None (e.g., empty input), start from last_inserted_index
            current_index = (app.last_inserted_index if hasattr(app, 'last_inserted_index') and app.last_inserted_index is not None else -1) if app.current_active_line_index is None else app.current_active_line_index
            new_index = current_index + 1
            
            # If past end, loop to first non-empty line
            if new_index >= len(lines):
                new_index = 0
                while new_index < len(lines):
                    if lines[new_index].strip():
                        app.current_active_line_index = new_index
                        app.current_active_line = lines[new_index].strip()
                        app.entry.setText(app.current_active_line)
                        app.entry.setCursorPosition(0)
                        app.first_up_after_submission = False
                        print(f"Loop a primera l√≠nea: {app.current_active_line}")
                        return
                    new_index += 1
            
            # Find next non-empty line
            while new_index < len(lines):
                if lines[new_index].strip():
                    app.current_active_line_index = new_index
                    app.current_active_line = lines[new_index].strip()
                    app.entry.setText(app.current_active_line)
                    app.entry.setCursorPosition(0)
                    app.first_up_after_submission = False
                    print(f"L√≠nea siguiente mostrada: {app.current_active_line}")
                    return
                new_index += 1
            
            # If no next non-empty line, loop to first non-empty line
            new_index = 0
            while new_index < len(lines):
                if lines[new_index].strip():
                    app.current_active_line_index = new_index
                    app.current_active_line = lines[new_index].strip()
                    app.entry.setText(app.current_active_line)
                    app.entry.setCursorPosition(0)
                    app.first_up_after_submission = False
                    print(f"Loop a primera l√≠nea: {app.current_active_line}")
                    return
                new_index += 1
            
            print("No hay l√≠neas no vac√≠as en el archivo.")
            app.current_active_line = None
            app.current_active_line_index = None
            app.first_up_after_submission = False
            app.entry.clear()
        else:
            print(f"El archivo {os.path.basename(app.current_file_path)} no existe.")
            app.current_active_line = None
            app.current_active_line_index = None
            app.first_up_after_submission = False
            app.entry.clear()
    except Exception as e:
        print(f"Error al mostrar l√≠nea siguiente: {e}")
        app.current_active_line = None
        app.current_active_line_index = None
        app.first_up_after_submission = False
        app.entry.clear()

# --- files.py ---
# --- files.py ---
import os
import random
import re
import datetime
import sys

def setup_file_handling(app):
    """Initializes file handling for the active file and ensures void_dir exists."""
    # Ensure void_dir exists
    if not os.path.exists(app.void_dir):
        os.makedirs(app.void_dir)
    
    # Ensure the active file (current_file_path) exists
    if not os.path.exists(app.current_file_path):
        with open(app.current_file_path, 'w', encoding='utf-8') as f:
            f.write('')
        print(f"Created active file: {app.current_file_path}")
    
    # Ensure 0.txt exists (as a fallback or for commands like //)
    if not os.path.exists(app.void_file_path):
        with open(app.void_file_path, 'w', encoding='utf-8') as f:
            f.write('')
        print(f"Created 0.txt: {app.void_file_path}")
    
    # Initialize navigation state
    app.current_active_line = None
    app.current_active_line_index = None
    app.last_inserted_index = None
    print(f"File handling initialized. Active file: {app.current_file_path}")

def void_line(app, event=None):
    """Procesa la l√≠nea ingresada, formate√°ndola y guard√°ndola en el archivo activo,
       o ejecutando un comando de archivo (cambiar o mover bloques/l√≠neas)."""
    try:
        line = app.entry.text().strip()
        app.entry.clear()
        app.entry.setFocus()

        if not line:
            app.current_active_line_index = None 
            app.current_active_line = None
            
            # --- MODIFICACI√ìN AQU√ç: Mover al final del archivo si la entrada est√° vac√≠a ---
            lines_in_file = []
            if os.path.exists(app.current_file_path):
                with open(app.current_file_path, 'r', encoding='utf-8') as f:
                    lines_in_file = f.readlines()
            
            # Establecer last_inserted_index al √≠ndice de la √∫ltima l√≠nea (o -1 si est√° vac√≠o)
            # Esto asegura que la pr√≥xima inserci√≥n se haga al final del archivo.
            app.last_inserted_index = len(lines_in_file) - 1 

            print(f"Input vac√≠o: Reiniciando √≠ndice de l√≠nea activa y estableciendo last_inserted_index a {app.last_inserted_index} (final del archivo).")
            return # No hacer nada m√°s si la l√≠nea est√° vac√≠a
        # --- FIN MODIFICACI√ìN ---

        # --- Nuevo: Verificar si se intenta a√±adir un punto consecutivo ---
        last_line_in_file = None
        if os.path.exists(app.current_file_path):
            with open(app.current_file_path, 'r', encoding='utf-8') as f:
                # Leer l√≠neas en reversa para encontrar la √∫ltima l√≠nea no vac√≠a eficientemente
                # y evitar cargar todo el archivo en memoria si es muy grande.
                lines = f.readlines()
                for l in reversed(lines):
                    stripped_l = l.strip()
                    if stripped_l: # Encontrar la √∫ltima l√≠nea que no est√© vac√≠a
                        last_line_in_file = stripped_l
                        break

        # Si la entrada es un solo punto y la √∫ltima l√≠nea en el archivo tambi√©n es un solo punto,
        # entonces no se procesa esta entrada.
        if line == '.' and last_line_in_file == '.':
            print("Se evit√≥ a√±adir puntos √∫nicos consecutivos.")
            app.current_active_line_index = None
            app.current_active_line = None
            app.last_inserted_index = None
            return # No procesar esta entrada

        # --- 1. Manejo de comandos de cambio de archivo (//) ---
        if line.startswith("//"):
            target_filename = line[2:].strip()
            if not target_filename: # Si solo se escribe "//", ir a 0.txt
                target_filename = "0" 
            
            # Normalizar el nombre del archivo
            if not target_filename.lower().endswith(".txt"):
                target_filename += ".txt"
            
            new_file_full_path = os.path.join(app.void_dir, target_filename)

            if new_file_full_path != app.current_file_path:
                # Cambiar el archivo activo
                app.current_file_path = new_file_full_path
                # Crear el archivo si no existe
                if not os.path.exists(app.current_file_path):
                    with open(app.current_file_path, 'w', encoding='utf-8') as f:
                        f.write('')
                    print(f"Archivo creado: {os.path.basename(app.current_file_path)}")
                
                # Update txt_files and current_file_index
                if new_file_full_path not in app.txt_files:
                    app.txt_files.append(new_file_full_path)
                    app.txt_files.sort()
                app.current_file_index = app.txt_files.index(new_file_full_path)
                
                print(f"Cambiado al archivo: {os.path.basename(app.current_file_path)}")
                # Resetear el estado de navegaci√≥n para el nuevo archivo
                app.current_active_line = None
                app.current_active_line_index = None
                app.last_inserted_index = None
            else:
                print(f"Ya est√°s en el archivo: {os.path.basename(app.current_file_path)}")
            return # Finalizar procesamiento de esta l√≠nea

        # --- 2. Manejo de "Mover una Sola L√≠nea" (Ej: "Mi contenido /nombre_archivo") ---
        # Busca el patr√≥n de texto seguido de un espacio y el comando /filename al final de la l√≠nea.
        match_single_line_move = re.search(r'(.*)\s+/([a-zA-Z0-9_.-]+\.txt|[a-zA-Z0-9_.-]+)$', line)
        
        if match_single_line_move:
            content_to_move = match_single_line_move.group(1).strip()
            target_filename_raw = match_single_line_move.group(2).strip()

            if not target_filename_raw:
                print("Comando de mover l√≠nea incompleto.")
                return

            target_filename = target_filename_raw
            if not target_filename.lower().endswith(".txt"):
                target_filename += ".txt"
            target_file_path = os.path.join(app.void_dir, target_filename)

            # Asegurar que el archivo de destino exista
            if not os.path.exists(target_file_path):
                with open(target_file_path, 'w', encoding='utf-8') as f:
                    f.write('')
            
            # Mover el contenido al archivo de destino
            with open(target_file_path, 'a', encoding='utf-8') as target_f:
                target_f.write(content_to_move + '\n')
            print(f"L√≠nea '{content_to_move}' movida a {os.path.basename(target_file_path)}")

            # Ahora, eliminar la l√≠nea del archivo de origen si fue una edici√≥n/reemplazo
            if app.current_active_line_index is not None:
                all_file_lines = []
                if os.path.exists(app.current_file_path):
                    with open(app.current_file_path, 'r', encoding='utf-8') as f:
                        all_file_lines = f.readlines()
                
                # Eliminar la l√≠nea original que conten√≠a el comando
                if app.current_active_line_index < len(all_file_lines):
                    del all_file_lines[app.current_active_line_index]
                
                # Reescribir el archivo de origen
                with open(app.current_file_path, 'w', encoding='utf-8') as current_f:
                    current_f.writelines(all_file_lines)
                    current_f.flush()
                    os.fsync(current_f.fileno())
                
                # Si el archivo de origen queda vac√≠o despu√©s de eliminar la l√≠nea (y no es 0.txt), eliminarlo
                if not all_file_lines and app.current_file_path != app.void_file_path:
                    os.remove(app.current_file_path)
                    print(f"Archivo {os.path.basename(app.current_file_path)} vac√≠o y eliminado.")
                    app.current_file_path = app.void_file_path # Volver a 0.txt
                    app.current_file_index = app.txt_files.index(app.current_file_path)
                    print(f"Regresando al archivo: {os.path.basename(app.current_file_path)}")

            app.current_active_line = None
            app.current_active_line_index = None
            app.last_inserted_index = None
            return # Finalizar procesamiento de esta l√≠nea

        # --- 3. Manejo de "Mover Bloque Completo" (Ej: "/nombre_archivo" en una l√≠nea sola) ---
        if line.startswith("/"): # Solo si no fue manejado por el caso anterior
            target_filename_raw = line[1:].strip()
            if not target_filename_raw:
                print("Comando de mover bloque incompleto. Escribe /nombre_archivo.txt")
                return
            
            target_filename = target_filename_raw
            if not target_filename.lower().endswith(".txt"):
                target_filename += ".txt"
            target_file_path = os.path.join(app.void_dir, target_filename)

            all_file_lines = []
            if os.path.exists(app.current_file_path):
                with open(app.current_file_path, 'r', encoding='utf-8') as f:
                    all_file_lines = f.readlines()
            
            # Determinar el √≠ndice donde el comando fue/ser√° insertado
            command_insert_index = len(all_file_lines) # Por defecto, al final
            if app.current_active_line_index is not None:
                command_insert_index = app.current_active_line_index
            
            # Encontrar el inicio del bloque a mover (√∫ltimo punto antes de command_insert_index)
            block_start_index = 0
            for i in range(command_insert_index - 1, -1, -1):
                if all_file_lines[i].strip() == '.':
                    block_start_index = i
                    break
            
            # Extraer el bloque a mover
            block_to_move = all_file_lines[block_start_index : command_insert_index]
            
            # >>> CORRECCI√ìN: NUNCA insertar el comando como texto normal si no hay bloque <<<
            if not block_to_move:
                print(f"No se encontr√≥ un bloque para mover con el comando '{line}'. No se realiz√≥ ninguna acci√≥n en el archivo.")
                app.current_active_line = None
                app.current_active_line_index = None
                app.last_inserted_index = None
                return # Simplemente retornar, sin modificar el archivo de origen.

            # Asegurar que el archivo de destino exista
            if not os.path.exists(target_file_path):
                with open(target_file_path, 'w', encoding='utf-8') as f:
                    f.write('')
            
            # >>> NUEVA L√ìGICA: A√±adir punto al inicio del bloque en el archivo de destino <<<
            with open(target_file_path, 'r+', encoding='utf-8') as target_f: # Abrir para leer y escribir
                target_content = target_f.read()
                # Si el archivo est√° vac√≠o o no termina con un punto, a√±adir un punto antes del bloque
                if not target_content.strip() or target_content.strip().endswith('.'):
                    # Si termina con un punto, o est√° vac√≠o, a√±adir el bloque directamente
                    # (el punto inicial del bloque se a√±adir√° al escribir)
                    pass 
                else: # Si termina sin punto, pero no est√° vac√≠o, asegurar que haya un punto antes de a√±adir el nuevo bloque
                    target_f.write('.\n') # A√±adir un punto para separar el bloque anterior del nuevo

                # Mover el puntero al final del archivo para a√±adir el nuevo contenido
                target_f.seek(0, os.SEEK_END)
                
                # El bloque debe empezar con un punto en el destino
                final_block_to_write = []
                if not block_to_move[0].strip() == '.': # Si el bloque no empieza ya con un punto, a√±adir uno
                    final_block_to_write.append('.\n')
                final_block_to_write.extend(block_to_move)

                target_f.writelines(final_block_to_write)
            
            # --- CORRECCI√ìN: El comando NO se incluye en new_source_lines aqu√≠. ---
            # Construir las nuevas l√≠neas del archivo de origen:
            # L√≠neas antes del bloque + l√≠neas despu√©s de la l√≠nea del comando (excluyendo el comando)
            new_source_lines = all_file_lines[:block_start_index] + all_file_lines[command_insert_index + 1:]

            # >>> NUEVA L√ìGICA: Reinsertar punto en el archivo de origen si es necesario <<<
            # Esto ocurre si hab√≠a contenido antes Y despu√©s del bloque extra√≠do,
            # y la l√≠nea justo antes del bloque extra√≠do NO era ya un punto.
            if block_start_index > 0 and command_insert_index + 1 <= len(all_file_lines): # <= para incluir el caso de que command_insert_index sea el √∫ltimo
                # Verificar si la l√≠nea que estaba justo antes del inicio del bloque movido (all_file_lines[block_start_index - 1])
                # era un punto. Si no lo era, y el bloque que se movi√≥ S√ç comenz√≥ con un punto
                # (o simplemente hay una brecha entre dos secciones que ahora necesitan un punto)
                # entonces reinsertamos un punto en el origen.
                
                # Si la l√≠nea justo ANTES de la brecha no era un punto
                # Y hay contenido ANTES y DESPU√âS de la brecha.
                if all_file_lines[block_start_index - 1].strip() != '.':
                    # Insertar un punto en la posici√≥n donde sol√≠a comenzar el bloque movido
                    new_source_lines.insert(block_start_index, '.\n')

            # Reescribir el archivo de origen
            with open(app.current_file_path, 'w', encoding='utf-8') as current_f:
                current_f.writelines(new_source_lines)
                current_f.flush()
                os.fsync(current_f.fileno())

            print(f"Bloque movido de {os.path.basename(app.current_file_path)} a {os.path.basename(target_file_path)}")
            
            # Si el archivo de origen queda completamente vac√≠o (incluyendo la ausencia del comando), y no es 0.txt, eliminarlo.
            if not new_source_lines and app.current_file_path != app.void_file_path:
                os.remove(app.current_file_path)
                print(f"Archivo {os.path.basename(app.current_file_path)} vac√≠o y eliminado.")
                app.current_file_path = app.void_file_path # Volver a 0.txt
                app.current_file_index = app.txt_files.index(app.current_file_path)
                print(f"Regresando al archivo: {os.path.basename(app.current_file_path)}")

            app.current_active_line = None
            app.current_active_line_index = None
            app.last_inserted_index = None
            return # Finalizar procesamiento de esta l√≠nea

        # --- 4. Manejo de texto normal (si no es un comando) ---
        # MODIFICACI√ìN APLICADA AQU√ç (Opci√≥n 1)
        if line == '.': # <-- Si la l√≠nea es SOLO un punto, la tratamos de forma especial
            formatted_lines = ['.'] # La lista de l√≠neas formateadas es solo un punto.
        else: 
            protected = line.replace("...", "<ELLIPSIS>")
            raw_sentences = re.split(r'\.(?=\s|$)', protected) 
            formatted_lines = []
            for raw in raw_sentences:
                s = raw.strip()
                if not s:
                    continue
                s = s.replace("<ELLIPSIS>", "...") 
                s = s[0].upper() + s[1:] if s else s
                if not s.endswith('.') and not s.endswith('...'):
                    s += '.'
                formatted_lines.append(s) 
        formatted_text = '\n'.join(formatted_lines)

        # Leer l√≠neas del archivo activo
        with open(app.current_file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines() 

        if hasattr(app, 'current_active_line_index') and app.current_active_line_index is not None:
            # Si estamos editando una l√≠nea existente (navegaci√≥n previa/siguiente)
            if app.current_active_line_index < len(lines): 
                lines[app.current_active_line_index] = formatted_text + '\n'
                app.last_inserted_index = app.current_active_line_index
                app.current_active_line = formatted_text
                app.current_active_line_index = None  # Reset to allow appending next time
            else:
                # Si el √≠ndice est√° fuera de rango, a√±adir como nueva l√≠nea
                insert_index = len(lines)
                lines.append(formatted_text + '\n')
                app.last_inserted_index = insert_index
                app.current_active_line = formatted_text
                app.current_active_line_index = None
        else:
            # Si estamos a√±adiendo una nueva l√≠nea
            insert_index = (app.last_inserted_index + 1) if hasattr(app, 'last_inserted_index') and app.last_inserted_index is not None else len(lines)
            
            # Asegurarse de que el √≠ndice de inserci√≥n no exceda el n√∫mero de l√≠neas existentes + 1
            if insert_index > len(lines):
                insert_index = len(lines)

            lines[insert_index:insert_index] = [line_to_add + '\n' for line_to_add in formatted_lines]
            app.last_inserted_index = insert_index + len(formatted_lines) - 1 
            app.current_active_line = formatted_text
            app.current_active_line_index = None  # Reset to allow appending next time

        # Escribir todas las l√≠neas de vuelta al archivo activo
        with open(app.current_file_path, 'w', encoding='utf-8') as f:
            f.writelines(lines)
            f.flush()
            os.fsync(f.fileno())
        
        print(f"L√≠neas insertadas/modificadas en {os.path.basename(app.current_file_path)}.") 
        app.first_up_after_submission = True  # Enable special navigation for first Up press

    except Exception as e:
        print(f"Error en void_line: {e}") 
        app.entry.clear()
        app.entry.setFocus()

# --- line_ring.py ---
class LineRing:
    def __init__(self, lines=None):
        self.lines = list(lines) if lines else [""]
        self.index = 0

    def current(self):
        return self.lines[self.index]

    def move(self, delta):
        if not self.lines:
            return
        self.index = (self.index + delta) % len(self.lines)

    def get(self, offset=0):
        if not self.lines:
            return ""
        return self.lines[(self.index + offset) % len(self.lines)]

    def insert(self, text, after_current=False):
        pos = self.index + 1 if after_current else self.index
        self.lines.insert(pos, text)
        if after_current:
            self.move(1)

    def remove_current(self):
        if len(self.lines) <= 1:
            self.lines = [""]
            self.index = 0
            return
        del self.lines[self.index]
        if self.index >= len(self.lines):
            self.index = len(self.lines) - 1

    def to_list_from_current(self):
        """Para exportar/imprimir con la l√≠nea actual primero"""
        return self.lines[self.index:] + self.lines[:self.index]

# --- new_interface.py ---
import os
import sys
import numpy as np
from PyQt6.QtWidgets import QApplication, QMainWindow, QLineEdit, QLabel, QWidget
from PyQt6.QtGui import QColor, QPainter, QFont, QCursor, QPen, QPixmap, QImage
from PyQt6.QtCore import Qt, QTimer, pyqtSignal

from files import setup_file_handling, void_line
from controls import setup_controls, show_random_line_from_current_file, show_previous_current_file_line, show_next_current_file_line, show_random_line_from_random_file
from noise_controls import NoiseController
from line_ring import LineRing
from circular_view import CircularView

class CustomLineEdit(QLineEdit):
    spacePressed = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent

    def keyPressEvent(self, event):
        key = event.key()
        modifiers = event.modifiers()

        if key == Qt.Key.Key_Space:
            if self.parent.use_spacebar_for_void:
                self.spacePressed.emit()
                event.accept()
                return
            super().keyPressEvent(event)
            return

        if key == Qt.Key.Key_0 and (modifiers & Qt.KeyboardModifier.ControlModifier):
            show_random_line_from_random_file(self.parent, event)
            event.accept()
        elif key == Qt.Key.Key_Period and (modifiers & Qt.KeyboardModifier.ControlModifier):
            show_random_line_from_current_file(self.parent, event)
            event.accept()
        else:
            super().keyPressEvent(event)


class CircleBackground(QWidget):
    def __init__(self, parent=None, center_x=0, center_y=0, radius=0):
        super().__init__(parent)
        self.center_x = center_x
        self.center_y = center_y
        self.radius = radius
        self.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        pen = QPen(QColor("white"), 10)
        painter.setPen(pen)
        painter.setBrush(Qt.BrushStyle.NoBrush)
        painter.drawEllipse(self.center_x - self.radius, self.center_y - self.radius,
                            self.radius * 2, self.radius * 2)

    def resizeEvent(self, event):
        self.resize(self.parent().size())


class NoiseOverlay(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.noise_pixmap = None
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.generate_noise)
        self.timer.start(50)

    def generate_noise(self):
        block_size = 1
        w, h = self.width(), self.height()
        h_blocks, w_blocks = h // block_size, w // block_size
        noise_gray = np.random.randint(0, 256, (h_blocks, w_blocks), dtype=np.uint8)
        image = QImage(noise_gray.data, w_blocks, h_blocks, w_blocks, QImage.Format.Format_Grayscale8)
        image = image.scaled(w, h, Qt.AspectRatioMode.IgnoreAspectRatio, Qt.TransformationMode.FastTransformation)
        self.noise_pixmap = QPixmap.fromImage(image)
        self.update()

    def paintEvent(self, event):
        if self.noise_pixmap:
            painter = QPainter(self)
            painter.setOpacity(0.09)
            painter.drawPixmap(0, 0, self.noise_pixmap)


class FullscreenCircleApp(QMainWindow):
    def __init__(self, read_dir=None, void_dir=None, file_to_open=None):
        super().__init__()
        self.opacity = 1.0
        self.read_dir = read_dir
        self.void_dir = void_dir
        self.file_to_open = file_to_open
        self.txt_files = []
        self.current_file_index = 0

        self.setWindowTitle("Voider")
        self.setWindowFlag(Qt.WindowType.FramelessWindowHint)
        self.setCursor(QCursor(Qt.CursorShape.BlankCursor))
        self.setStyleSheet("background-color: black;")

        self.entry = CustomLineEdit(self)
        self.entry.setFont(QFont("Consolas", 11))
        self.entry.setStyleSheet("""
            QLineEdit {
                background-color: black;
                color: white;
                border: none;
                qproperty-alignment: AlignCenter;
                selection-background-color: white;
                selection-color: black;
            }
        """)
        self.entry.setFocus()

        self.loading = QLabel("Loading potentiality", self)
        self.loading.setFont(QFont("Consolas", 11))
        self.loading.setStyleSheet("color: white; background-color: black;")
        self.loading.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.loading.resize(300, 100)
        self.loading.hide()

        self.noise_controller = NoiseController(
            block_size=1024, volume=0.3, noise_type='brown',
            bitcrush={'bit_depth': 10, 'sample_rate_factor': 0.7},
            lfo_min_freq=0.03, lfo_max_freq=0.1, glitch_prob=0.005, cutoff_freq=2500
        )

        # ‚îÄ‚îÄ Modo circular ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        self.circular_mode = False
        self.line_ring = None
        self.circular_view = None
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        self.setup_voider_logic()

        self.use_spacebar_for_void = False
        self._print_void_mode_status()
        self._void_enter_connection = None
        self._void_space_connection = None
        self._connect_void_key()

        self.init_ui()

    # M√©todos para modo void (Enter / Space) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    def _print_void_mode_status(self):
        print("VOID MODE:", "Spacebar" if self.use_spacebar_for_void else "Enter", "(F2 para cambiar)")

    def _connect_void_key(self):
        self._disconnect_void_key()
        if self.use_spacebar_for_void:
            self._void_space_connection = self.entry.spacePressed.connect(lambda: void_line(self))
        else:
            self._void_enter_connection = self.entry.returnPressed.connect(lambda: void_line(self))

    def _disconnect_void_key(self):
        if self._void_enter_connection:
            try: self.entry.returnPressed.disconnect(self._void_enter_connection)
            except: pass
            self._void_enter_connection = None
        if self._void_space_connection:
            try: self.entry.spacePressed.disconnect(self._void_space_connection)
            except: pass
            self._void_space_connection = None

    def toggle_void_key_mode(self):
        self.use_spacebar_for_void = not self.use_spacebar_for_void
        self._print_void_mode_status()
        self._connect_void_key()
        self.entry.setFocus()

    # Toggle modo circular ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    def toggle_circular_mode(self):
        self.circular_mode = not self.circular_mode

        if self.circular_mode:
            try:
                with open(self.current_file_path, 'r', encoding='utf-8') as f:
                    lines = [l.strip() for l in f if l.strip()]
                self.line_ring = LineRing(lines or [""])
            except:
                self.line_ring = LineRing([""])

            self.circular_view = CircularView(self.line_ring, self)
            self.circular_view.resize(self.size())
            self.circular_view.show()
            self.entry.hide()
            self.circular_view.setFocus()
        else:
            if self.circular_view:
                self.circular_view.deleteLater()
                self.circular_view = None
            self.entry.show()
            self.entry.setFocus()

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def setup_voider_logic(self):
        self.current_file_path = self.file_to_open or os.path.join(self.void_dir, '0.txt')
        self.void_file_path = os.path.join(self.void_dir, '0.txt')
        self.scan_txt_files()
        setup_file_handling(self)
        setup_controls(self)

    def scan_txt_files(self):
        dir_path = os.path.dirname(self.current_file_path)
        self.txt_files = [os.path.join(dir_path, f) for f in os.listdir(dir_path)
                          if f.lower().endswith('.txt') and os.path.isfile(os.path.join(dir_path, f))]
        self.txt_files.sort()
        if self.current_file_path in self.txt_files:
            self.current_file_index = self.txt_files.index(self.current_file_path)
        else:
            self.txt_files.append(self.current_file_path)
            self.txt_files.sort()
            self.current_file_index = self.txt_files.index(self.current_file_path)

    def switch_to_file(self, file_path):
        if not os.path.exists(file_path):
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write('')
        self.current_file_path = file_path
        self.current_file_index = self.txt_files.index(file_path)
        self.entry.clear()

    def show_previous_file(self):
        if not self.txt_files: return
        self.current_file_index = (self.current_file_index - 1) % len(self.txt_files)
        self.switch_to_file(self.txt_files[self.current_file_index])

    def show_next_file(self):
        if not self.txt_files: return
        self.current_file_index = (self.current_file_index + 1) % len(self.txt_files)
        self.switch_to_file(self.txt_files[self.current_file_index])

    def init_ui(self):
        self.showFullScreen()
        screen = self.screen().availableGeometry()
        self.center_x = screen.width() // 2
        self.center_y = screen.height() // 2
        self.radius = min(screen.width(), screen.height()) // 2 - 35
        entry_width = self.radius * 2 - 40

        self.entry.setFixedWidth(entry_width)
        self.entry.move(self.center_x - entry_width // 2, self.center_y - self.entry.height() // 2)

        self.loading.move(self.center_x - 150, self.center_y - 50)
        self.loading.show()
        QTimer.singleShot(1500, self.loading.deleteLater)

        self.circle_background = CircleBackground(self, self.center_x, self.center_y, self.radius)
        self.circle_background.resize(self.size())
        self.circle_background.show()

        self.noise_overlay = NoiseOverlay(self)
        self.noise_overlay.resize(self.size())
        self.noise_overlay.show()
        self.noise_overlay.raise_()

    def resizeEvent(self, event):
        super().resizeEvent(event)
        if hasattr(self, 'noise_overlay'):
            self.noise_overlay.resize(self.size())
        if hasattr(self, 'circle_background'):
            self.circle_background.resize(self.size())
        if hasattr(self, 'circular_view') and self.circular_view:
            self.circular_view.resize(self.size())

        screen = self.screen().availableGeometry()
        self.center_x = screen.width() // 2
        self.center_y = screen.height() // 2
        self.radius = min(screen.width(), screen.height()) // 2 - 35
        entry_width = self.radius * 2 - 40
        self.entry.setFixedWidth(entry_width)
        self.entry.move(self.center_x - entry_width // 2, self.center_y - self.entry.height() // 2)

    def keyPressEvent(self, event):
        key = event.key()
        modifiers = event.modifiers()

        if key == Qt.Key.Key_F2:
            self.toggle_void_key_mode()
            event.accept()
            return

        if key == Qt.Key.Key_F3:           # ‚Üê tecla para toggle circular (cambia si quieres)
            self.toggle_circular_mode()
            event.accept()
            return

        if self.circular_mode:
            if key == Qt.Key.Key_Up:
                self.circular_view.animate_move(-1)
                event.accept()
            elif key == Qt.Key.Key_Down:
                self.circular_view.animate_move(1)
                event.accept()
            elif key == Qt.Key.Key_Escape:
                self.toggle_circular_mode()
                event.accept()
            return

        # Modo normal
        if key == Qt.Key.Key_Escape:
            self.noise_controller.stop()
            self.close()
        elif key == Qt.Key.Key_Up and modifiers == Qt.KeyboardModifier.ControlModifier:
            self.increase_opacity()
        elif key == Qt.Key.Key_Down and modifiers == Qt.KeyboardModifier.ControlModifier:
            self.decrease_opacity()
        elif key == Qt.Key.Key_Up and modifiers == Qt.KeyboardModifier.AltModifier:
            self.show_previous_file()
        elif key == Qt.Key.Key_Down and modifiers == Qt.KeyboardModifier.AltModifier:
            self.show_next_file()
        elif key == Qt.Key.Key_Up:
            show_previous_current_file_line(self)
        elif key == Qt.Key.Key_Down:
            show_next_current_file_line(self)

    def increase_opacity(self):
        self.opacity = min(1.0, self.opacity + 0.1)
        self.setWindowOpacity(self.opacity)

    def decrease_opacity(self):
        self.opacity = max(0.0, self.opacity - 0.1)
        self.setWindowOpacity(self.opacity)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    read_directory = 'read_potential'
    void_directory = 'void_potential'
    os.makedirs(read_directory, exist_ok=True)
    os.makedirs(void_directory, exist_ok=True)
    window = FullscreenCircleApp(read_dir=read_directory, void_dir=void_directory)
    sys.exit(app.exec())

# --- noise_controls.py ---
# --- noise_controls.py ---
import numpy as np
import sounddevice as sd
from PyQt6.QtCore import QTimer

class NoiseController:
    def __init__(self, sample_rate=44100, block_size=1024, volume=0.01, noise_type='brown',
                 bitcrush={'bit_depth': 8, 'sample_rate_factor': 0.6},
                 lfo_min_freq=0.01, lfo_max_freq=0.03, glitch_prob=0.001, cutoff_freq=300):
        self.sample_rate = sample_rate
        self.block_size = block_size
        self.volume = volume
        self.noise_type = noise_type
        self.bitcrush = bitcrush
        self.lfo_min_freq = lfo_min_freq
        self.lfo_max_freq = lfo_max_freq
        self.glitch_prob = glitch_prob
        self.cutoff_freq = cutoff_freq
        self.stream = None
        self.timer = None
        self.lfo_state = 0

        try:
            self.stream = sd.OutputStream(
                samplerate=sample_rate,
                blocksize=block_size,
                channels=2,
                callback=self.audio_callback
            )
            self.stream.start()
            self.start_lfo_generator()
            print(f"NoiseController: {self.noise_type.capitalize()} subtle meditative noise started.")
        except Exception as e:
            print(f"NoiseController: Error initializing audio: {str(e)}")

    def lowpass_filter(self, data, cutoff, alpha=0.1):
        """
        Filtro pasa bajos simple usando un filtro de media m√≥vil exponencial.
        `alpha` controla la suavidad (m√°s bajo = m√°s suave).
        """
        filtered = np.zeros_like(data)
        filtered[0] = data[0]
        for i in range(1, len(data)):
            filtered[i] = alpha * data[i] + (1 - alpha) * filtered[i - 1]
        return filtered

    def apply_bitcrush(self, noise, bit_depth=16, sample_rate_factor=1.0):
        original_length = len(noise)
        if sample_rate_factor < 1.0:
            new_length = int(original_length * sample_rate_factor)
            new_length = max(1, new_length)
            indices = np.linspace(0, original_length - 1, new_length).astype(int)
            noise = noise[indices]
            noise = np.tile(noise, (original_length // len(noise) + 1))[:original_length]
        if bit_depth < 16:
            max_val = 2 ** (bit_depth - 1) - 1
            noise = np.round(noise / 32767 * max_val) / max_val * 32767
        return noise.astype(np.int16)

    def generate_variable_lfo(self, t, min_freq, max_freq):
        n_points = 4
        rand_freqs = np.random.uniform(min_freq, max_freq, n_points)
        rand_phases = np.random.uniform(0, 2 * np.pi, n_points)
        key_times = np.linspace(0, self.block_size / self.sample_rate, n_points)
        freqs = np.interp(t, key_times, rand_freqs)
        phases = np.interp(t, key_times, rand_phases)
        return 0.97 + 0.03 * np.sin(2 * np.pi * freqs * t + phases)

    def audio_callback(self, outdata, frames, time, status):
        if status:
            print(f"Audio callback status: {status}")
        if frames != self.block_size:
            return

        if self.noise_type == 'brown':
            white = np.random.uniform(-1, 1, frames)
            brown = np.cumsum(white)
            noise = brown / np.max(np.abs(brown)) * 0.8
        elif self.noise_type == 'white':
            noise = np.random.uniform(-1, 1, frames)
        elif self.noise_type == 'pink':
            white = np.random.uniform(-1, 1, frames)
            pink = np.cumsum(white) / np.arange(1, frames + 1) ** 0.5
            noise = pink / np.max(np.abs(pink)) * 0.8
        else:
            noise = np.zeros(frames)

        noise = self.lowpass_filter(noise, cutoff=self.cutoff_freq)

        t = np.linspace(self.lfo_state, self.lfo_state + frames / self.sample_rate, frames)
        self.lfo_state += frames / self.sample_rate
        noise *= self.generate_variable_lfo(t, self.lfo_min_freq, self.lfo_max_freq)

        if np.random.rand() < 0.25:  # reducir cantidad de glitches
            glitch_mask = np.random.random(frames) < self.glitch_prob
            noise[glitch_mask] *= np.random.uniform(0.9, 1.1, glitch_mask.sum())

        if self.bitcrush:
            bit_depth = self.bitcrush.get('bit_depth', 8)
            sample_rate_factor = self.bitcrush.get('sample_rate_factor', 0.6)
            noise = (noise * 32767).astype(np.float32)
            noise = self.apply_bitcrush(noise, bit_depth, sample_rate_factor)

        noise = noise / np.max(np.abs(noise)) * 0.1 * self.volume
        stereo_noise = np.repeat(noise[:, np.newaxis], 2, axis=1)
        outdata[:] = stereo_noise

    def start_lfo_generator(self):
        self.timer = QTimer()
        self.timer.timeout.connect(lambda: None)
        self.timer.start(100)

    def stop(self):
        if self.stream:
            self.stream.stop()
            self.stream.close()
        if self.timer:
            self.timer.stop()
        print("NoiseController: Stopped")

    def set_volume(self, volume):
        self.volume = max(0.0, min(1.0, volume))
        print(f"NoiseController: Volume set to {self.volume:.2f}")

    def set_noise_type(self, noise_type):
        self.noise_type = noise_type
        print(f"NoiseController: Noise type set to {self.noise_type}")

    def set_bitcrush(self, bitcrush):
        self.bitcrush = bitcrush
        print(f"NoiseController: Bitcrush set to {self.bitcrush}")

    def set_lfo_freq(self, min_freq, max_freq):
        self.lfo_min_freq = min_freq
        self.lfo_max_freq = max_freq
        print(f"NoiseController: LFO freq range set to {min_freq:.2f}-{max_freq:.2f} Hz")

    def set_glitch_prob(self, prob):
        self.glitch_prob = max(0.0, min(0.1, prob))
        print(f"NoiseController: Glitch probability set to {self.glitch_prob:.4f}")

    def set_cutoff_freq(self, cutoff):
        self.cutoff_freq = max(50, min(8000, cutoff))
        print(f"NoiseController: Cutoff frequency set to {self.cutoff_freq} Hz")


# --- test_circular.py ---
from PyQt6.QtWidgets import QApplication, QMainWindow, QWidget
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QFont, QCursor
import sys
import os

from line_ring import LineRing
from circular_view import CircularView


class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Circular View Test")
        self.setWindowFlag(Qt.WindowType.FramelessWindowHint)
        self.setCursor(QCursor(Qt.CursorShape.BlankCursor))
        self.setStyleSheet("background: black; color: white;")

        # Cargar archivo 0.txt
        possible_paths = [
            os.path.join("void_potential", "0.txt"),
            os.path.join("void", "0.txt"),
            "0.txt",
            os.path.join(os.path.dirname(__file__), "void_potential", "0.txt"),
            os.path.join(os.path.dirname(__file__), "void", "0.txt"),
        ]
        
        lines = None
        self.file_path = None
        
        for path in possible_paths:
            if os.path.exists(path):
                try:
                    with open(path, encoding="utf-8") as f:
                        lines = [l.strip() for l in f if l.strip()]
                    self.file_path = path
                    print(f"‚úÖ Archivo cargado: {path}")
                    break
                except Exception as e:
                    print(f"‚ùå Error leyendo {path}: {e}")
        
        if lines is None or not lines:
            lines = [
                "Bienvenido a Circular View",
                "Presiona Enter para editar",
                "Usa ‚Üë y ‚Üì para navegar",
                "ESC para salir",
                "Las ediciones se guardan autom√°ticamente"
            ]
            print(f"‚ö†Ô∏è Usando l√≠neas de ejemplo")

        # Crear ring y vista
        self.ring = LineRing(lines)
        self.view = CircularView(self.ring, self)
        
        # Conectar se√±al de guardado autom√°tico
        self.view.line_saved.connect(self.auto_save)
        
        font = QFont("Consolas", 11)
        self.view.setFont(font)
        
        self.setCentralWidget(self.view)
        self.showFullScreen()

    def auto_save(self):
        """Guarda autom√°ticamente despu√©s de cada edici√≥n"""
        if self.file_path:
            try:
                with open(self.file_path, 'w', encoding='utf-8') as f:
                    for line in self.ring.lines:
                        f.write(line + '\n')
                print(f"üíæ Auto-guardado en {self.file_path}")
            except Exception as e:
                print(f"‚ùå Error en auto-guardado: {e}")

    def keyPressEvent(self, event):
        """Captura las teclas de navegaci√≥n y edici√≥n"""
        key = event.key()
        
        if self.view.edit_mode:
            # En modo edici√≥n, ESC cancela (Enter lo maneja el editor)
            if key == Qt.Key.Key_Escape:
                self.view.cancel_edit()
                event.accept()
        else:
            # En modo scroll
            if key == Qt.Key.Key_Up:
                self.view.animate_move(-1)
                event.accept()
            elif key == Qt.Key.Key_Down:
                self.view.animate_move(1)
                event.accept()
            elif key == Qt.Key.Key_Return or key == Qt.Key.Key_Enter:
                self.view.enter_edit_mode()
                event.accept()
            elif key == Qt.Key.Key_Escape:
                self.save_and_exit()

    def save_and_exit(self):
        """Guardar cambios y salir (por si acaso, aunque ya hay auto-save)"""
        self.auto_save()  # Un √∫ltimo save antes de salir
        self.close()


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    sys.exit(app.exec())

# --- test_voider.py ---
# test_voider.py
# Sistema de tests completo para el proyecto Voider.
# Usa pytest para testing, ya que es conciso y soporta fixtures bien.
# Este archivo debe colocarse en la ra√≠z del proyecto.
# Para ejecutar: python -m pytest test_voider.py
# (Aseg√∫rate de tener pytest instalado: pip install pytest)

import os
import random
import tempfile
import pytest
from unittest.mock import MagicMock, patch

# Importar m√≥dulos del proyecto
from controls import (
    setup_controls,
    show_random_line_from_current_file,
    show_random_line_from_random_file,
    show_previous_current_file_line,
    show_next_current_file_line
)
from files import setup_file_handling, void_line
from tools import clean_text, close_program, show_cursor
from noise_controls import NoiseController
# from new_interface import FullscreenCircleApp  # UI testing es opcional/complejo, se mockea
# from voider import ...  # Main script, no se testa directamente

# Fixture para crear un mock de la app (simula FullscreenCircleApp sin Qt)
@pytest.fixture
def mock_app():
    app = MagicMock()
    app.void_dir = tempfile.mkdtemp()  # Directorio temporal para tests de archivos
    app.void_file_path = os.path.join(app.void_dir, '0.txt')
    app.current_file_path = app.void_file_path
    app.txt_files = [app.void_file_path]
    app.current_file_index = 0
    app.entry = MagicMock()  # Mock para el QLineEdit
    app.entry.text.return_value = ""
    app.entry.setText = MagicMock()
    app.entry.setCursorPosition = MagicMock()
    app.entry.clear = MagicMock()
    app.current_active_line = None
    app.current_active_line_index = None
    app.last_inserted_index = None
    app.first_up_after_submission = False
    yield app
    # Cleanup: eliminar directorio temporal
    for file in os.listdir(app.void_dir):
        os.remove(os.path.join(app.void_dir, file))
    os.rmdir(app.void_dir)

# Fixture para setup inicial (llama a setup_file_handling y setup_controls)
@pytest.fixture
def setup_app(mock_app):
    setup_file_handling(mock_app)
    setup_controls(mock_app)
    yield mock_app

# --- Tests para controls.py ---

def test_setup_controls(setup_app):
    """Prueba que setup_controls inicialice el estado de navegaci√≥n correctamente."""
    assert setup_app.first_up_after_submission == False

def test_show_random_line_from_current_file(setup_app):
    """Prueba selecci√≥n de l√≠nea aleatoria del archivo actual, excluyendo la actual si posible."""
    # Caso: archivo vac√≠o
    show_random_line_from_current_file(setup_app)
    assert setup_app.current_active_line is None
    assert setup_app.current_active_line_index is None
    setup_app.entry.clear.assert_called()

    # Caso: archivo con l√≠neas
    with open(setup_app.current_file_path, 'w', encoding='utf-8') as f:
        f.write("Line1\nLine2\nLine3\n")
    setup_app.current_active_line = "Line2"  # Simular l√≠nea actual
    with patch('random.choice') as mock_choice:
        mock_choice.return_value = "Line1"
        show_random_line_from_current_file(setup_app)
        assert setup_app.current_active_line == "Line1"
        assert setup_app.current_active_line_index == 0
        setup_app.entry.setText.assert_called_with("Line1")
        setup_app.entry.setCursorPosition.assert_called_with(0)

    # Caso: solo una l√≠nea
    with open(setup_app.current_file_path, 'w', encoding='utf-8') as f:
        f.write("OnlyLine\n")
    show_random_line_from_current_file(setup_app)
    assert setup_app.current_active_line == "OnlyLine"
    assert setup_app.current_active_line_index == 0

def test_show_random_line_from_random_file(setup_app):
    """Prueba selecci√≥n de l√≠nea aleatoria de un archivo aleatorio, excluyendo el actual si posible."""
    # Caso: sin archivos
    setup_app.txt_files = []
    show_random_line_from_random_file(setup_app)
    assert setup_app.current_active_line is None
    setup_app.entry.clear.assert_called()

    # Caso: m√∫ltiples archivos
    file2 = os.path.join(setup_app.void_dir, '1.txt')
    with open(file2, 'w', encoding='utf-8') as f:
        f.write("LineA\nLineB\n")
    setup_app.txt_files = [setup_app.current_file_path, file2]
    with open(setup_app.current_file_path, 'w', encoding='utf-8') as f:
        f.write("CurrentLine\n")
    with patch('random.choice') as mock_choice:
        mock_choice.side_effect = [file2, "LineA"]  # Primero elige archivo, luego l√≠nea
        show_random_line_from_random_file(setup_app)
        # Verificar que el archivo seleccionado est√° en txt_files
        assert setup_app.current_file_path in setup_app.txt_files
        # Si se seleccion√≥ file2, verificar que la l√≠nea es de file2
        if setup_app.current_file_path == file2:
            assert setup_app.current_active_line == "LineA"
            assert setup_app.current_active_line_index == 0
        # Verificar que el √≠ndice del archivo se actualiz√≥ correctamente
        assert setup_app.current_file_index == setup_app.txt_files.index(setup_app.current_file_path)
        setup_app.entry.setText.assert_called_with("LineA")
        setup_app.entry.setCursorPosition.assert_called_with(0)

    # Caso: archivo vac√≠o seleccionado
    with open(file2, 'w', encoding='utf-8') as f:
        f.write("")
    setup_app.txt_files = [setup_app.current_file_path, file2]  # Restaurar txt_files
    with patch('random.choice') as mock_choice:
        mock_choice.return_value = file2
        show_random_line_from_random_file(setup_app)
        assert setup_app.current_active_line is None
        # Verificar que el archivo seleccionado est√° en txt_files, incluso si es vac√≠o
        assert setup_app.current_file_path in setup_app.txt_files
        assert setup_app.current_file_index == setup_app.txt_files.index(setup_app.current_file_path)
        setup_app.entry.clear.assert_called()

def test_show_previous_current_file_line(setup_app):
    """Prueba navegaci√≥n a l√≠nea anterior, con loop y l√≥gica de first_up_after_submission."""
    # Caso: archivo vac√≠o
    show_previous_current_file_line(setup_app)
    assert setup_app.current_active_line is None
    setup_app.entry.clear.assert_called()

    # Caso: con l√≠neas, first_up_after_submission=True
    with open(setup_app.current_file_path, 'w', encoding='utf-8') as f:
        f.write("Line1\nLine2\nLine3\n")
    setup_app.first_up_after_submission = True
    setup_app.last_inserted_index = 1  # "Line2"
    show_previous_current_file_line(setup_app)
    assert setup_app.current_active_line == "Line2"
    assert setup_app.current_active_line_index == 1
    assert setup_app.first_up_after_submission == False

    # Caso: navegaci√≥n normal con loop
    setup_app.current_active_line_index = 0
    show_previous_current_file_line(setup_app)
    assert setup_app.current_active_line == "Line3"  # Loop al final
    assert setup_app.current_active_line_index == 2

    # Caso: l√≠neas vac√≠as (salta)
    with open(setup_app.current_file_path, 'w', encoding='utf-8') as f:
        f.write("Line1\n\nLine3\n")
    setup_app.current_active_line_index = 2
    show_previous_current_file_line(setup_app)
    assert setup_app.current_active_line == "Line1"
    assert setup_app.current_active_line_index == 0

def test_show_next_current_file_line(setup_app):
    """Prueba navegaci√≥n a l√≠nea siguiente, con loop."""
    # Caso: archivo vac√≠o
    show_next_current_file_line(setup_app)
    assert setup_app.current_active_line is None

    # Caso: con l√≠neas, desde None usa last_inserted_index
    with open(setup_app.current_file_path, 'w', encoding='utf-8') as f:
        f.write("Line1\nLine2\nLine3\n")
    setup_app.current_active_line_index = None
    setup_app.last_inserted_index = 0
    show_next_current_file_line(setup_app)
    assert setup_app.current_active_line == "Line2"
    assert setup_app.current_active_line_index == 1

    # Caso: loop al principio
    setup_app.current_active_line_index = 2
    show_next_current_file_line(setup_app)
    assert setup_app.current_active_line == "Line1"
    assert setup_app.current_active_line_index == 0

    # Caso: l√≠neas vac√≠as (salta)
    with open(setup_app.current_file_path, 'w', encoding='utf-8') as f:
        f.write("Line1\n\nLine3\n")
    setup_app.current_active_line_index = 0
    show_next_current_file_line(setup_app)
    assert setup_app.current_active_line == "Line3"
    assert setup_app.current_active_line_index == 2

# --- Tests para files.py ---

def test_setup_file_handling(mock_app):
    """Prueba inicializaci√≥n de manejo de archivos, crea directorios y archivos si no existen."""
    # Eliminar void_dir temporalmente para test
    os.rmdir(mock_app.void_dir)
    setup_file_handling(mock_app)
    assert os.path.exists(mock_app.void_dir)
    assert os.path.exists(mock_app.current_file_path)
    assert os.path.exists(mock_app.void_file_path)
    assert mock_app.current_active_line is None
    assert mock_app.current_active_line_index is None
    assert mock_app.last_inserted_index is None

def test_void_line(setup_app):
    """Prueba procesamiento de l√≠neas: inserci√≥n, edici√≥n, comandos, formateo, movimientos."""
    # Caso: input vac√≠o - resetea √≠ndices y mueve al final
    setup_app.entry.text.return_value = ""
    void_line(setup_app)
    assert setup_app.current_active_line_index is None
    assert setup_app.last_inserted_index == -1  # Archivo vac√≠o

    # Caso: input normal con formateo
    setup_app.entry.text.return_value = "test sentence without period"
    void_line(setup_app)
    with open(setup_app.current_file_path, 'r') as f:
        content = f.read().strip()
    assert content == "Test sentence without period."

    # Caso: punto solo, no consecutivo
    setup_app.entry.text.return_value = "."
    void_line(setup_app)
    with open(setup_app.current_file_path, 'r') as f:
        lines = f.readlines()
    assert lines[-1].strip() == "."

    # Caso: punto consecutivo evitado
    setup_app.entry.text.return_value = "."
    void_line(setup_app)
    with open(setup_app.current_file_path, 'r') as f:
        lines = f.readlines()
    assert len(lines) == 2  # No se a√±adi√≥ el segundo punto

    # Caso: comando cambio de archivo //
    setup_app.entry.text.return_value = "//1"
    void_line(setup_app)
    assert setup_app.current_file_path == os.path.join(setup_app.void_dir, "1.txt")
    assert os.path.exists(setup_app.current_file_path)

    # Caso: mover l√≠nea simple "content /file"
    setup_app.entry.text.return_value = "Move this /2.txt"
    void_line(setup_app)
    target_path = os.path.join(setup_app.void_dir, "2.txt")
    with open(target_path, 'r') as f:
        assert f.read().strip() == "Move this"

    # Caso: mover bloque "/file"
    with open(setup_app.current_file_path, 'w') as f:
        f.write(".\nBlock line1\nBlock line2\n")
    setup_app.entry.text.return_value = "/3.txt"
    void_line(setup_app)
    target_path = os.path.join(setup_app.void_dir, "3.txt")
    with open(target_path, 'r') as f:
        assert f.read().strip() == ".\nBlock line1\nBlock line2"

    # Caso: edici√≥n de l√≠nea existente
    with open(setup_app.current_file_path, 'w') as f:
        f.write("Old line\n")
    setup_app.current_active_line_index = 0
    setup_app.entry.text.return_value = "New line."
    void_line(setup_app)
    with open(setup_app.current_file_path, 'r') as f:
        assert f.read().strip() == "New line."

    # Caso: error (mock exception)
    with patch('builtins.open') as mock_open:
        mock_open.side_effect = Exception("Test error")
        void_line(setup_app)
        setup_app.entry.clear.assert_called()

# --- Tests para tools.py ---

def test_clean_text():
    """Prueba que clean_text devuelva el texto sin cambios (seg√∫n implementaci√≥n actual)."""
    assert clean_text("test") == "test"
    assert clean_text("") == ""

def test_close_program(setup_app):
    """Prueba cierre de la app."""
    close_program(setup_app)
    setup_app.close.assert_called()

def test_show_cursor(setup_app):
    """Prueba mostrar cursor en entry."""
    show_cursor(setup_app)
    setup_app.entry.setCursorVisible.assert_called_with(True)

# --- Tests para noise_controls.py ---

def test_noise_controller_init():
    """Prueba inicializaci√≥n de NoiseController."""
    nc = NoiseController()
    assert nc.sample_rate == 44100
    assert nc.volume == 0.01
    assert nc.noise_type == 'brown'
    nc.stop()  # Cleanup

def test_noise_controller_methods():
    """Prueba setters de NoiseController."""
    nc = NoiseController()
    nc.set_volume(0.5)
    assert nc.volume == 0.5
    nc.set_noise_type('white')
    assert nc.noise_type == 'white'
    nc.set_bitcrush({'bit_depth': 10})
    assert nc.bitcrush['bit_depth'] == 10
    nc.set_lfo_freq(0.02, 0.04)
    assert nc.lfo_min_freq == 0.02
    nc.set_glitch_prob(0.002)
    assert nc.glitch_prob == 0.002
    nc.set_cutoff_freq(1000)
    assert nc.cutoff_freq == 1000
    nc.stop()

# Para expandir: agrega nuevas funciones de test aqu√≠ o en fixtures separadas.

# --- tools.py ---
# --- tools.py ---
def clean_text(text):
    return text  # Devolver texto sin cambios

def close_program(app, event=None):
    app.close()

def show_cursor(app, event=None):
    app.entry.setCursorVisible(True)

# --- voider.py ---
# --- voider.py ---
import os
import sys
from PyQt6.QtWidgets import QApplication
from new_interface import FullscreenCircleApp

if __name__ == "__main__":
    try:
        if getattr(sys, 'frozen', False):
            # If running as an executable (PyInstaller), app_path is the directory of the .exe
            app_path = os.path.dirname(sys.executable)
            # For EXE, void_dir is the same directory as the executable
            void_dir = app_path
            print(f"EXE Mode: Files will be saved directly in the executable's directory.")
        else:
            # If running as a Python script, app_path is the directory of the script
            app_path = os.path.dirname(os.path.abspath(__file__))
            # For script, void_dir is a 'void' subdirectory
            void_dir = os.path.join(app_path, 'void')
            print(f"Script Mode: Files will be saved in the 'void' subdirectory.")

        # Check for command-line arguments
        file_to_open = None
        if len(sys.argv) > 1:
            # Get the first argument (potential file path)
            candidate_file = sys.argv[1]
            # Verify it's a .txt file and exists (or can be created)
            if candidate_file.lower().endswith('.txt'):
                # Convert to absolute path to handle drag-and-drop or relative paths
                candidate_file = os.path.abspath(candidate_file)
                if os.path.exists(candidate_file) or os.path.dirname(candidate_file) == void_dir:
                    file_to_open = candidate_file
                    print(f"Opening specified file: {file_to_open}")
                else:
                    print(f"File {candidate_file} does not exist and is not in void_dir. Defaulting to 0.txt.")
            else:
                print(f"Argument {candidate_file} is not a .txt file. Defaulting to 0.txt.")
        
        # If no valid file was provided, default to 0.txt in void_dir
        if not file_to_open:
            file_to_open = os.path.join(void_dir, '0.txt')
            print(f"No file specified. Defaulting to: {file_to_open}")

        read_dir = os.path.dirname(app_path)
        
        print(f"Working directory: {os.getcwd()}")
        print(f"App path: {app_path}")
        print(f"Void dir (where files are saved): {void_dir}")
        print(f"Active file: {file_to_open}")
        
        app = QApplication(sys.argv)
        # Pass void_dir and the file to open to FullscreenCircleApp
        window = FullscreenCircleApp(read_dir=read_dir, void_dir=void_dir, file_to_open=file_to_open)
        window.show()
        print("Window shown")
        sys.exit(app.exec())
    except Exception as e:
        print(f"Error: {e}")
        input("Press Enter to exit...")

# --- __init__.py ---

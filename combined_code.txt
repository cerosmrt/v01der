

# --- controls.py ---
# --- controls.py ---
import random
import os
from files import setup_file_handling, void_line
from tools import clean_text
from PyQt6.QtWidgets import QApplication

def setup_controls(app):
    pass  # Los eventos están en keyPressEvent y returnPressed

def show_random_line_from_zero(app, event=None):
    """Muestra una línea aleatoria de 0.txt y guarda su índice para reemplazo."""
    try:
        zero_file_path = app.void_file_path
        print(f"Intentando leer: {zero_file_path}")
        if os.path.exists(zero_file_path):
            with open(zero_file_path, 'r', encoding='utf-8') as f:
                lines = [line.rstrip('\n') for line in f.readlines() if line.strip()]
            if lines:
                app.current_zero_line = random.choice(lines)
                app.current_zero_line_index = lines.index(app.current_zero_line)
                app.entry.setText(app.current_zero_line)
                app.entry.setCursorPosition(0)  # Mover cursor al inicio
                print(f"Random line from 0.txt: {app.current_zero_line}, Index: {app.current_zero_line_index}")
            else:
                print("0.txt está vacío.")
                app.entry.clear()
                app.current_zero_line = None
                app.current_zero_line_index = None
        else:
            print("0.txt no existe.")
            app.entry.clear()
            app.current_zero_line = None
            app.current_zero_line_index = None
    except Exception as e:
        print(f"Error en show_random_line_from_zero: {e}")

def handle_key_press(app, event=None):
    """Función original para mezclar archivos (guardada para uso futuro)."""
    random.shuffle(app.txt_files)
    if app.txt_files:
        app.current_file = app.txt_files[0]
        file_lines = app.file_line_map.get(app.current_file, [])
        if file_lines:
            app.current_line_index = random.randint(0, len(file_lines) - 1)
            app.current_line = file_lines[app.current_line_index]
            app.entry.setText(app.current_line)
            for file in app.txt_files:
                app.file_positions[file] = random.randint(0, len(app.file_line_map.get(file, [])) - 1) if app.file_line_map.get(file) else 0
            app.navigation_direction = random.choice([1, -1])
            print("\nShuffled files:", app.txt_files)
            print("File positions:", app.file_positions)
            print(f"Showing random line: {app.current_line}, Index: {app.current_line_index}")
            print(f"Navigation direction: {'normal' if app.navigation_direction == 1 else 'inverted'}")

def show_previous_file(app, event=None):
    if not app.txt_files:
        return
    if app.current_file:
        app.file_positions[app.current_file] = app.current_line_index
    current_file_index = app.txt_files.index(app.current_file) if app.current_file else 0
    previous_file_index = (current_file_index - 1) % len(app.txt_files)
    app.current_file = app.txt_files[previous_file_index]
    file_lines = app.file_line_map.get(app.current_file, [])
    if file_lines:
        app.current_line_index = app.file_positions.get(app.current_file, 0) % len(file_lines)
        app.current_line = file_lines[app.current_line_index]
        app.entry.setText(app.current_line)
        print(f"Previous File - Now at: {app.current_file}, Index: {app.current_line_index}, Line: {app.current_line}")

def show_next_file(app, event=None):
    if not app.txt_files:
        return
    if not app.entry.text().strip() and app.current_line == "":
        file_lines = app.file_line_map.get(app.current_file, [])
        if file_lines:
            app.current_line_index = app.file_positions.get(app.current_file, 0) % len(file_lines)
            app.current_line = file_lines[app.current_line_index]
            app.entry.setText(app.current_line)
            print(f"Next File - First show: {app.current_file}, Index: {app.current_line_index}, Line: {app.current_line}")
    else:
        if app.current_file:
            app.file_positions[app.current_file] = app.current_line_index
        current_file_index = app.txt_files.index(app.current_file) if app.current_file else -1
        next_file_index = (current_file_index + 1) % len(app.txt_files)
        app.current_file = app.txt_files[next_file_index]
        file_lines = app.file_line_map.get(app.current_file, [])
        if file_lines:
            app.current_line_index = app.file_positions.get(app.current_file, 0) % len(file_lines)
            app.current_line = file_lines[app.current_line_index]
            app.entry.setText(app.current_line)
            print(f"Next File - Now at: {app.current_file}, Index: {app.current_line_index}, Line: {app.current_line}")

def show_previous_line(app, event=None):
    if not app.current_file or not app.file_line_map.get(app.current_file, []):
        return
    file_lines = app.file_line_map[app.current_file]
    app.current_line_index = (app.current_line_index - 1) % len(file_lines)
    app.current_line = file_lines[app.current_line_index]
    app.entry.setText(app.current_line)
    app.file_positions[app.current_file] = app.current_line_index
    print(f"Previous Line - File: {app.current_file}, Index: {app.current_line_index}, Line: {app.current_line}")

def show_next_line(app, event=None):
    if not app.current_file or not app.file_line_map.get(app.current_file, []):
        return
    file_lines = app.file_line_map[app.current_file]
    app.current_line_index = (app.current_line_index + 1) % len(file_lines)
    app.current_line = file_lines[app.current_line_index]
    app.entry.setText(app.current_line)
    app.file_positions[app.current_file] = app.current_line_index
    print(f"Next Line - File: {app.current_file}, Index: {app.current_line_index}, Line: {app.current_line}")

# --- files.py ---
# --- files.py ---
import os
import random
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

def setup_file_handling(app):
    app.txt_files = []
    update_txt_files(app)
    index_all_lines(app)
    if app.txt_files:
        app.current_file = app.txt_files[0]
        app.current_line_index = 0
        app.current_line = ""
        app.entry.clear()
    
    app.event_handler = FileSystemEventHandler()
    app.event_handler.on_created = lambda event: on_directory_change(app, event)
    app.event_handler.on_deleted = lambda event: on_directory_change(app, event)
    app.observer = Observer()
    app.observer.schedule(app.event_handler, app.void_dir, recursive=False)
    app.observer.start()

def update_txt_files(app):
    if not os.path.exists(app.void_dir):
        os.makedirs(app.void_dir)
    if not os.path.exists(app.void_file_path):
        with open(app.void_file_path, 'w', encoding='utf-8') as void_file:
            void_file.write('')
    new_txt_files = [f for f in os.listdir(app.read_dir) if f.endswith('.txt') and f != '0.txt']
    if not hasattr(app, 'txt_files') or not app.txt_files:
        app.txt_files = new_txt_files
        app.file_positions = {file: 0 for file in app.txt_files}
    else:
        app.txt_files = new_txt_files
        for file in new_txt_files:
            if file not in app.file_positions:
                app.file_positions[file] = 0

def index_all_files(app):
    all_files = os.listdir(app.read_dir)
    app.txt_files = [
        f for f in all_files
        if f.endswith('.txt') and f != '0.txt' and os.path.getsize(os.path.join(app.read_dir, f)) > 0
    ]
    if app.txt_files and not hasattr(app, 'current_file'):
        app.current_file = app.txt_files[0]

def index_all_lines(app):
    app.all_lines = []
    app.file_line_map = {}

    for txt_file in app.txt_files:
        file_path = os.path.join(app.read_dir, txt_file)
        if os.path.exists(file_path):
            with open(file_path, 'r', encoding='utf-8') as file:
                lines = [line.strip() for line in file.readlines() if line.strip()]
                app.file_line_map[txt_file] = lines
                app.all_lines.extend(lines)

    print("Líneas indexadas (total):", len(app.all_lines))
    print("Primeras 5 líneas:", app.all_lines[:5])
    print("Líneas por archivo:", {k: len(v) for k, v in app.file_line_map.items()})

def refresh_files(app, event=None):
    print("Refrescando archivos y líneas...")
    update_txt_files(app)
    index_all_lines(app)
    app.current_file = app.txt_files[0] if app.txt_files else None
    app.current_line_index = 0
    app.current_line = ""
    app.entry.clear()
    print("Refresh completo. Entry vacío, listo para navegar.")

def on_directory_change(app, event):
    if event.event_type in ('created', 'deleted'):
        old_files = set(app.txt_files)
        update_txt_files(app)
        new_files = set(app.txt_files)
        if old_files != new_files:
            index_all_lines(app)
            print("Reindexado por cambio en archivos")

def void_line(app, event=None):
    import re
    try:
        line = app.entry.text().strip()
        app.entry.clear()
        app.entry.setFocus()

        if line:
            # --- FORMATO ---
            # Proteger los puntos suspensivos
            protected = line.replace("...", "<ELLIPSIS>")
            raw_sentences = re.split(r'\.(?=\s|$)', protected)

            formatted_lines = []
            for raw in raw_sentences:
                s = raw.strip()
                if not s:
                    continue
                s = s.replace("<ELLIPSIS>", "...")
                s = s[0].upper() + s[1:] if s else s
                if not s.endswith('.') and not s.endswith('...'):
                    s += '.'
                formatted_lines.append(s)

            formatted_text = '\n'.join(formatted_lines)

            # --- FIN FORMATO ---

            if line.startswith("/"):
                base, ext = os.path.splitext(app.void_file_path)
                if line == "/":
                    num_digits = random.randint(1, 10)
                    random_number = ''.join([str(random.randint(0, 9)) for _ in range(num_digits)])
                    new_file_path = f"{base}_{random_number}{ext}"
                else:
                    new_name = line[1:]
                    new_file_path = os.path.join(app.void_dir, f"{new_name}{ext}")
                if os.path.exists(new_file_path):
                    with open(app.void_file_path, 'r', encoding='utf-8') as void_file:
                        content_to_append = void_file.read()
                    with open(new_file_path, 'a', encoding='utf-8') as target_file:
                        target_file.write(content_to_append)
                    with open(app.void_file_path, 'w', encoding='utf-8') as void_file:
                        void_file.write('')
                else:
                    os.rename(app.void_file_path, new_file_path)
                    with open(app.void_file_path, 'w', encoding='utf-8') as void_file:
                        void_file.write('')
                app.last_inserted_index = None
            else:
                with open(app.void_file_path, 'r', encoding='utf-8') as f:
                    lines = f.readlines()

                if hasattr(app, 'current_zero_line_index') and app.current_zero_line_index is not None:
                    if app.current_zero_line_index < len(lines):
                        lines[app.current_zero_line_index] = formatted_text + '\n'
                        app.last_inserted_index = app.current_zero_line_index
                    app.current_zero_line_index = None
                    app.current_zero_line = None
                else:
                    insert_index = (app.last_inserted_index + 1) if hasattr(app, 'last_inserted_index') and app.last_inserted_index is not None else len(lines)
                    lines.insert(insert_index, formatted_text + '\n')
                    app.last_inserted_index = insert_index

                with open(app.void_file_path, 'w', encoding='utf-8') as f:
                    f.writelines(lines)
                    f.flush()
                    os.fsync(f.fileno())
        else:
            app.current_zero_line_index = None
            app.current_zero_line = None

        return 'break'

    except Exception as e:
        print(f"Error en void_line: {e}")
        app.entry.clear()
        app.entry.setFocus()
        return 'break'

# --- new_interface.py ---
# --- new_interface.py ---
import os
import sys
import numpy as np
from PyQt6.QtWidgets import QApplication, QMainWindow, QLineEdit, QLabel, QWidget
from PyQt6.QtGui import QColor, QPainter, QFont, QCursor, QPen, QPixmap, QImage
from PyQt6.QtCore import Qt, QTimer
from files import setup_file_handling, void_line
from controls import setup_controls, show_next_line, show_previous_line, show_random_line_from_zero
from noise_controls import NoiseController

class CustomLineEdit(QLineEdit):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent

    def keyPressEvent(self, event):
        key = event.key()
        print(f"Tecla en QLineEdit: {key}, Key_0: {Qt.Key.Key_0}")
        if key == Qt.Key.Key_0:
            print("Tecla 0 detectada en QLineEdit, ejecutando show_random_line_from_zero")
            self.parent.last_inserted_index = None
            show_random_line_from_zero(self.parent, event)
            event.accept()
        else:
            super().keyPressEvent(event)

class CircleBackground(QWidget):
    def __init__(self, parent=None, center_x=0, center_y=0, radius=0):
        super().__init__(parent)
        self.center_x = center_x
        self.center_y = center_y
        self.radius = radius
        self.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        pen = QPen(QColor("white"), 10)
        painter.setPen(pen)
        painter.setBrush(Qt.BrushStyle.NoBrush)
        painter.drawEllipse(
            self.center_x - self.radius,
            self.center_y - self.radius,
            self.radius * 2,
            self.radius * 2
        )

    def resizeEvent(self, event):
        self.resize(self.parent().size())

class NoiseOverlay(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.noise_pixmap = None
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.generate_noise)
        self.timer.start(100)

    def generate_noise(self):
        block_size = 2
        w, h = self.width(), self.height()
        h_blocks, w_blocks = h // block_size, w // block_size
        noise_rgb = np.random.randint(0, 256, (h_blocks, w_blocks, 3), dtype=np.uint8)
        image = QImage(noise_rgb.data, w_blocks, h_blocks, QImage.Format.Format_RGB888)
        image = image.scaled(w, h, Qt.AspectRatioMode.IgnoreAspectRatio, Qt.TransformationMode.FastTransformation)
        self.noise_pixmap = QPixmap.fromImage(image)
        self.update()

    def paintEvent(self, event):
        if self.noise_pixmap:
            painter = QPainter(self)
            painter.setOpacity(0.1)
            painter.drawPixmap(0, 0, self.noise_pixmap)

class FullscreenCircleApp(QMainWindow):
    def __init__(self, read_dir=None, void_dir=None):
        super().__init__()
        self.opacity = 1.0
        self.read_dir = read_dir or os.path.dirname(os.path.abspath(__file__))
        self.void_dir = void_dir or os.path.join(self.read_dir, 'void')
        self.setWindowTitle("Voider")
        self.setWindowFlag(Qt.WindowType.FramelessWindowHint)
        self.setCursor(QCursor(Qt.CursorShape.BlankCursor))
        self.setStyleSheet("background-color: black;")

        self.entry = CustomLineEdit(self)
        self.entry.setFont(QFont("Consolas", 11))
        self.entry.setStyleSheet("""
            QLineEdit {
                background-color: black;
                color: white;
                border: none;
                qproperty-alignment: AlignCenter;
                selection-background-color: white;
                selection-color: black;
            }
        """)
        self.entry.setFocus()
        self.entry.returnPressed.connect(lambda: void_line(self))

        self.loading = QLabel("Loading potentiality", self)
        self.loading.setFont(QFont("Consolas", 11))
        self.loading.setStyleSheet("color: white; background-color: black;")
        self.loading.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.loading.resize(300, 100)
        self.loading.hide()

        # Initialize noise controller for meditative noise
        self.noise_controller = NoiseController(
            block_size=1024, volume=0.3, noise_type='brown',
            bitcrush={'bit_depth': 10, 'sample_rate_factor': 0.7},
            lfo_min_freq=0.03, lfo_max_freq=0.1, glitch_prob=0.005, cutoff_freq=2500
        )

        self.setup_voider_logic()
        self.init_ui()

    def setup_voider_logic(self):
        os.makedirs(self.void_dir, exist_ok=True)
        self.void_file_path = os.path.join(self.void_dir, '0.txt')
        print(f"void_file_path inicializado: {self.void_file_path}")
        self.current_line = None
        self.current_file = None
        self.current_line_index = 0
        self.current_zero_line = None
        self.current_zero_line_index = None
        self.last_inserted_index = None
        self.file_positions = {}
        self.all_lines = []
        self.file_line_map = {}
        self.navigation_direction = 1
        setup_file_handling(self)
        setup_controls(self)

    def init_ui(self):
        print("Initializing UI")
        self.showFullScreen()
        screen = self.screen().availableGeometry()
        self.center_x = screen.width() // 2
        self.center_y = screen.height() // 2
        self.radius = min(screen.width(), screen.height()) // 2 - 35
        entry_width = self.radius * 2 - 40
        self.entry.setFixedWidth(entry_width)
        self.entry.move(self.center_x - entry_width // 2,
                        self.center_y - self.entry.height() // 2)
        self.loading.move(self.center_x - 150, self.center_y - 50)
        self.loading.show()
        QTimer.singleShot(1500, self.loading.deleteLater)
        self.circle_background = CircleBackground(self, self.center_x, self.center_y, self.radius)
        self.circle_background.resize(self.size())
        self.circle_background.show()
        self.noise_overlay = NoiseOverlay(self)
        self.noise_overlay.resize(self.size())
        self.noise_overlay.show()

    def resizeEvent(self, event):
        super().resizeEvent(event)
        if hasattr(self, 'noise_overlay'):
            self.noise_overlay.resize(self.size())
        if hasattr(self, 'circle_background'):
            self.circle_background.resize(self.size())

    def keyPressEvent(self, event):
        key = event.key()
        modifiers = event.modifiers()
        print(f"Tecla en ventana: {key}, Modificadores: {modifiers}")

        if key == Qt.Key.Key_Escape:
            self.noise_controller.stop()
            self.close()
        elif key == Qt.Key.Key_Up and modifiers == Qt.KeyboardModifier.ControlModifier:
            self.increase_opacity()
        elif key == Qt.Key.Key_Down and modifiers == Qt.KeyboardModifier.ControlModifier:
            self.decrease_opacity()
        elif key == Qt.Key.Key_Right:
            show_next_line(self)
        elif key == Qt.Key.Key_Left:
            show_previous_line(self)

    def increase_opacity(self):
        self.opacity = min(1.0, self.opacity + 0.1)
        self.setWindowOpacity(self.opacity)

    def decrease_opacity(self):
        self.opacity = max(0.0, self.opacity - 0.1)
        self.setWindowOpacity(self.opacity)

if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = FullscreenCircleApp()
    window.show()
    sys.exit(app.exec())

# --- noise_controls.py ---
# --- noise_controls.py ---
import numpy as np
import sounddevice as sd
from scipy.signal import butter, lfilter
from PyQt6.QtCore import QTimer

class NoiseController:
    def __init__(self, sample_rate=44100, block_size=1024, volume=0.01, noise_type='brown',
                 bitcrush={'bit_depth': 8, 'sample_rate_factor': 0.6},
                 lfo_min_freq=0.01, lfo_max_freq=0.03, glitch_prob=0.001, cutoff_freq=300):
        self.sample_rate = sample_rate
        self.block_size = block_size
        self.volume = volume
        self.noise_type = noise_type
        self.bitcrush = bitcrush
        self.lfo_min_freq = lfo_min_freq
        self.lfo_max_freq = lfo_max_freq
        self.glitch_prob = glitch_prob
        self.cutoff_freq = cutoff_freq
        self.stream = None
        self.timer = None
        self.lfo_state = 0

        try:
            self.stream = sd.OutputStream(
                samplerate=sample_rate,
                blocksize=block_size,
                channels=2,
                callback=self.audio_callback
            )
            self.stream.start()
            self.start_lfo_generator()
            print(f"NoiseController: {self.noise_type.capitalize()} subtle meditative noise started.")
        except Exception as e:
            print(f"NoiseController: Error initializing audio: {str(e)}")

    def lowpass_filter(self, data, cutoff, order=4):
        nyq = 0.5 * self.sample_rate
        normal_cutoff = cutoff / nyq
        b, a = butter(order, normal_cutoff, btype='low', analog=False)
        return lfilter(b, a, data, axis=0)

    def apply_bitcrush(self, noise, bit_depth=16, sample_rate_factor=1.0):
        original_length = len(noise)
        if sample_rate_factor < 1.0:
            new_length = int(original_length * sample_rate_factor)
            new_length = max(1, new_length)
            indices = np.linspace(0, original_length - 1, new_length).astype(int)
            noise = noise[indices]
            noise = np.tile(noise, (original_length // len(noise) + 1))[:original_length]
        if bit_depth < 16:
            max_val = 2 ** (bit_depth - 1) - 1
            noise = np.round(noise / 32767 * max_val) / max_val * 32767
        return noise.astype(np.int16)

    def generate_variable_lfo(self, t, min_freq, max_freq):
        n_points = 4
        rand_freqs = np.random.uniform(min_freq, max_freq, n_points)
        rand_phases = np.random.uniform(0, 2 * np.pi, n_points)
        key_times = np.linspace(0, self.block_size / self.sample_rate, n_points)
        freqs = np.interp(t, key_times, rand_freqs)
        phases = np.interp(t, key_times, rand_phases)
        return 0.97 + 0.03 * np.sin(2 * np.pi * freqs * t + phases)

    def audio_callback(self, outdata, frames, time, status):
        if status:
            print(f"Audio callback status: {status}")
        if frames != self.block_size:
            return

        if self.noise_type == 'brown':
            white = np.random.uniform(-1, 1, frames)
            brown = np.cumsum(white)
            noise = brown / np.max(np.abs(brown)) * 0.8
        elif self.noise_type == 'white':
            noise = np.random.uniform(-1, 1, frames)
        elif self.noise_type == 'pink':
            white = np.random.uniform(-1, 1, frames)
            pink = np.cumsum(white) / np.arange(1, frames + 1) ** 0.5
            noise = pink / np.max(np.abs(pink)) * 0.8
        else:
            noise = np.zeros(frames)

        noise = self.lowpass_filter(noise, cutoff=self.cutoff_freq)

        t = np.linspace(self.lfo_state, self.lfo_state + frames / self.sample_rate, frames)
        self.lfo_state += frames / self.sample_rate
        noise *= self.generate_variable_lfo(t, self.lfo_min_freq, self.lfo_max_freq)

        if np.random.rand() < 0.25:  # reducir cantidad de glitches
            glitch_mask = np.random.random(frames) < self.glitch_prob
            noise[glitch_mask] *= np.random.uniform(0.9, 1.1, glitch_mask.sum())

        if self.bitcrush:
            bit_depth = self.bitcrush.get('bit_depth', 8)
            sample_rate_factor = self.bitcrush.get('sample_rate_factor', 0.6)
            noise = (noise * 32767).astype(np.float32)
            noise = self.apply_bitcrush(noise, bit_depth, sample_rate_factor)

        noise = noise / np.max(np.abs(noise)) * 0.9 * self.volume
        stereo_noise = np.repeat(noise[:, np.newaxis], 2, axis=1)
        outdata[:] = stereo_noise

    def start_lfo_generator(self):
        self.timer = QTimer()
        self.timer.timeout.connect(lambda: None)
        self.timer.start(100)

    def stop(self):
        if self.stream:
            self.stream.stop()
            self.stream.close()
        if self.timer:
            self.timer.stop()
        print("NoiseController: Stopped")

    def set_volume(self, volume):
        self.volume = max(0.0, min(1.0, volume))
        print(f"NoiseController: Volume set to {self.volume:.2f}")

    def set_noise_type(self, noise_type):
        self.noise_type = noise_type
        print(f"NoiseController: Noise type set to {self.noise_type}")

    def set_bitcrush(self, bitcrush):
        self.bitcrush = bitcrush
        print(f"NoiseController: Bitcrush set to {self.bitcrush}")

    def set_lfo_freq(self, min_freq, max_freq):
        self.lfo_min_freq = min_freq
        self.lfo_max_freq = max_freq
        print(f"NoiseController: LFO freq range set to {min_freq:.2f}-{max_freq:.2f} Hz")

    def set_glitch_prob(self, prob):
        self.glitch_prob = max(0.0, min(0.1, prob))
        print(f"NoiseController: Glitch probability set to {self.glitch_prob:.4f}")

    def set_cutoff_freq(self, cutoff):
        self.cutoff_freq = max(50, min(8000, cutoff))
        print(f"NoiseController: Cutoff frequency set to {self.cutoff_freq} Hz")


# --- nuitka_build_installer .py ---
import os
import datetime
import subprocess
import sys

# Generar nombre con timestamp
timestamp = datetime.datetime.now().strftime('%y-%m-%d_%H-%M-%S')
exe_name = f'voider-{timestamp}'

# Rutas
base_dir = os.path.dirname(os.path.abspath(__file__))
build_dir = os.path.join(os.path.dirname(base_dir), 'builds')
icon_path = os.path.join(base_dir, 'voider.ico')
script_path = os.path.join(base_dir, 'new_interface.py')

# Comando de compilación con Nuitka
cmd = [
    sys.executable,  # Usa el mismo Python con el que ejecutás esto
    "-m", "nuitka",
    "--standalone",
    "--onefile",
    "--windows-disable-console",
    "--enable-plugin=pyqt6",
    "--enable-plugin=numpy",
    f"--include-data-file={icon_path}=voider.ico",
    f"--windows-icon-from-ico={icon_path}",
    f"--output-dir={build_dir}",
    "--nofollow-import-to=tkinter",
    f"--output-filename={exe_name}.exe",
    script_path
]

print(f"Compiling {exe_name}.exe with Nuitka...\n")
subprocess.run(cmd, shell=True)
print(f"\n✅ Done. Check the build folder: {os.path.join(build_dir, f'{exe_name}.exe')}")


# --- tools.py ---
# --- tools.py ---
def clean_text(text):
    return text  # Devolver texto sin cambios

def close_program(app, event=None):
    app.close()

def show_cursor(app, event=None):
    app.entry.setCursorVisible(True)

# --- voider.py ---
# --- voider.py ---
import os
import sys
from PyQt6.QtWidgets import QApplication
from new_interface import FullscreenCircleApp

if __name__ == "__main__":
    try:
        if getattr(sys, 'frozen', False):
            app_path = os.path.dirname(sys.executable)
        else:
            app_path = os.path.dirname(os.path.abspath(__file__))  # V01DER directory
        read_dir = os.path.dirname(app_path)  # Z:\programming\Voider\V2
        void_dir = os.path.join(app_path, 'void')  # Z:\programming\Voider\V2\V01DER\void
        print(f"Working directory: {os.getcwd()}")
        print(f"App path: {app_path}")
        print(f"Void dir: {void_dir}")
        if not os.path.exists(void_dir):
            print(f"Creating: {void_dir}")
            try:
                os.makedirs(void_dir)
            except Exception as e:
                print(f"Error creating void folder: {e}")
        else:
            print(f"Void folder exists: {void_dir}")
        app = QApplication(sys.argv)
        window = FullscreenCircleApp(read_dir=read_dir, void_dir=void_dir)
        window.show()
        print("Window shown")
        sys.exit(app.exec())
    except Exception as e:
        print(f"Error: {e}")
        input("Press Enter to exit...")

# --- __init__.py ---

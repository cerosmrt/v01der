

# --- build_exe.py ---
# SOLUCI√ìN 1: Script simplificado sin scipy problem√°tico
import os
import datetime
import sys
import PyInstaller.__main__

def build_simple():
    """Versi√≥n simplificada que evita el problema con scipy"""
    timestamp = datetime.datetime.now().strftime('%y-%m-%d_%H-%M-%S')
    exe_name = f'voider-{timestamp}'
    
    base_dir = os.path.dirname(os.path.abspath(__file__))
    build_root = os.path.join(base_dir, 'builds')
    dist_dir = os.path.join(build_root, 'dist')
    work_dir = os.path.join(build_root, 'build')
    spec_dir = build_root
    main_script = os.path.join(base_dir, 'voider.py')
    icon_path = os.path.join(base_dir, 'voider.ico')
    
    os.makedirs(dist_dir, exist_ok=True)
    os.makedirs(work_dir, exist_ok=True)
    os.makedirs(spec_dir, exist_ok=True)
    
    # Argumentos m√≠nimos - SIN scipy que est√° causando problemas
    args = [
        '--clean',
        '--onefile',  # Cambiar a onedir por ahora
        '--windowed',
        main_script,
        f'--name={exe_name}',
        f'--distpath={dist_dir}',
        f'--workpath={work_dir}',
        f'--specpath={spec_dir}',
        
        # Solo los imports esenciales
        '--hidden-import=PyQt6',
        '--hidden-import=PyQt6.QtCore',
        '--hidden-import=PyQt6.QtGui',
        '--hidden-import=PyQt6.QtWidgets',
        '--hidden-import=sounddevice',
        
        # Excluir scipy problem√°tico
        '--exclude-module=scipy',
        '--exclude-module=numpy.distutils',
    ]
    
    if os.path.exists(icon_path):
        args.append(f'--icon={icon_path}')
    
    print(f"üîß Construyendo versi√≥n simplificada: {exe_name}")
    try:
        PyInstaller.__main__.run(args)
        print("‚úÖ ¬°Versi√≥n simplificada completada!")
        return True
    except Exception as e:
        print(f"‚ùå Error en versi√≥n simplificada: {e}")
        return False

def build_with_spec_file():
    """SOLUCI√ìN 2: Crear archivo .spec personalizado"""
    timestamp = datetime.datetime.now().strftime('%y-%m-%d_%H-%M-%S')
    exe_name = f'voider-{timestamp}'
    
    base_dir = os.path.dirname(os.path.abspath(__file__))
    spec_content = f'''# -*- mode: python ; coding: utf-8 -*-

a = Analysis(
    ['voider.py'],
    pathex=['{base_dir.replace(chr(92), chr(92)+chr(92))}'],
    binaries=[],
    datas=[('voider.ico', '.')] if os.path.exists('voider.ico') else [],
    hiddenimports=[
        'PyQt6',
        'PyQt6.QtCore',
        'PyQt6.QtGui', 
        'PyQt6.QtWidgets',
        'sounddevice',
    ],
    hookspath=[],
    runtime_hooks=[],
    excludes=['scipy', 'matplotlib', 'tkinter', 'pygame', 'torch'],
    noarchive=False,
)

pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='{exe_name}',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon='voider.ico' if os.path.exists('voider.ico') else None,
)
'''
    
    spec_file = f'{exe_name}.spec'
    with open(spec_file, 'w') as f:
        f.write(spec_content)
    
    print(f"üìù Archivo .spec creado: {spec_file}")
    print("üîß Ejecuta manualmente: pyinstaller --clean " + spec_file)
    return spec_file

def build_conda_fix():
    """SOLUCI√ìN 3: Versi√≥n para entornos conda/problemas de dependencias"""
    timestamp = datetime.datetime.now().strftime('%y-%m-%d_%H-%M-%S')
    exe_name = f'voider-{timestamp}'
    
    base_dir = os.path.dirname(os.path.abspath(__file__))
    build_root = os.path.join(base_dir, 'builds')
    dist_dir = os.path.join(build_root, 'dist')
    work_dir = os.path.join(build_root, 'build')
    spec_dir = build_root
    main_script = os.path.join(base_dir, 'voider.py')
    
    os.makedirs(dist_dir, exist_ok=True)
    os.makedirs(work_dir, exist_ok=True)
    os.makedirs(spec_dir, exist_ok=True)
    
    args = [
        '--clean',
        '--onedir',
        '--console',  # Temporalmente para ver errores
        main_script,
        f'--name={exe_name}',
        f'--distpath={dist_dir}',
        f'--workpath={work_dir}',
        f'--specpath={spec_dir}',
        '--noupx',  # Desactivar UPX que a veces causa problemas
        '--debug=all',  # M√°s informaci√≥n de debug
    ]
    
    print(f"üîß Construyendo versi√≥n debug: {exe_name}")
    try:
        PyInstaller.__main__.run(args)
        print("‚úÖ ¬°Versi√≥n debug completada!")
        return True
    except Exception as e:
        print(f"‚ùå Error en versi√≥n debug: {e}")
        return False

def main():
    print("üöÄ Iniciando soluciones para PyInstaller...")
    print("=" * 50)
    
    # Informaci√≥n del sistema
    print("üìä Informaci√≥n del sistema:")
    print(f"   Python: {sys.version}")
    print(f"   Directorio: {os.getcwd()}")
    
    try:
        import PyInstaller
        print(f"   PyInstaller: {PyInstaller.__version__}")
    except:
        print("   PyInstaller: No disponible")
    
    try:
        import scipy
        print(f"   SciPy: {scipy.__version__}")
    except:
        print("   SciPy: No disponible")
    
    print("=" * 50)
    
    # Intentar soluciones en orden
    print("\n1Ô∏è‚É£ Intentando versi√≥n simplificada...")
    if build_simple():
        return
    
    print("\n2Ô∏è‚É£ Creando archivo .spec personalizado...")
    spec_file = build_with_spec_file()
    
    print("\n3Ô∏è‚É£ Intentando versi√≥n debug...")
    if build_conda_fix():
        return
    
    print("\n" + "=" * 50)
    print("üîß INSTRUCCIONES MANUALES:")
    print("=" * 50)
    print("Si nada funcion√≥ autom√°ticamente, prueba estos comandos manuales:")
    print()
    print("OPCI√ìN A - Sin scipy:")
    print("pyinstaller --onedir --windowed --clean voider.py --exclude-module=scipy")
    print()
    print("OPCI√ìN B - Solo lo esencial:")
    print("pyinstaller --onedir --console voider.py")
    print()
    print("OPCI√ìN C - Usar el .spec generado:")
    print(f"pyinstaller --clean {spec_file}")
    print()
    print("OPCI√ìN D - Actualizar PyInstaller:")
    print("pip install --upgrade pyinstaller")
    print()
    print("OPCI√ìN E - Crear entorno virtual limpio:")
    print("python -m venv venv_clean")
    print("venv_clean\\Scripts\\activate")
    print("pip install PyQt6 sounddevice pyinstaller")

if __name__ == "__main__":
    main()

# --- combined_code.py ---
import os

output_file = "combined_code.txt"
excluded_files = {
    "build_installer.py",
    "combined_py.py",
    "interface.py",
    "nuitka_build_installer.py",
    "realtime_effects.py",
    "test.py",
}

included_files = []

with open(output_file, "w", encoding="utf-8") as outfile:
    for file in os.listdir("."):
        if file.endswith(".py") and file not in excluded_files:
            included_files.append(file)
            with open(file, "r", encoding="utf-8") as infile:
                outfile.write(f"\n\n# --- {file} ---\n")    
                outfile.write(infile.read())

print(f"‚úÖ Combined .py files into '{output_file}'")
print("üóÇÔ∏è Archivos incluidos:")
for f in included_files:
    print(f" - {f}")


# --- controls.py ---
import random
import os
from files import setup_file_handling, void_line
from tools import clean_text
from PyQt6.QtWidgets import QApplication

def setup_controls(app):
    pass  # Los eventos est√°n en keyPressEvent y returnPressed

def show_random_line_from_current_file(app, event=None):
    """Muestra una l√≠nea aleatoria del archivo activo, evitando la l√≠nea actual."""
    try:
        current_file_path = app.current_file_path # Usa el archivo activo
        print(f"Intentando leer: {current_file_path}")
        if os.path.exists(current_file_path):
            with open(current_file_path, 'r', encoding='utf-8') as f:
                lines = [line.rstrip('\n') for line in f.readlines() if line.strip()]
            if lines:
                if len(lines) == 1:
                    selected_line = lines[0] # Solo hay una l√≠nea, no hay alternativa
                    selected_index = 0
                else:
                    # Hay m√∫ltiples l√≠neas, excluir la actual
                    current_line = getattr(app, 'current_active_line', None)
                    available_lines = [line for line in lines if line != current_line]
                    
                    if not available_lines:
                        available_lines = lines # Fallback: usar todas las l√≠neas
                    
                    selected_line = random.choice(available_lines)
                    selected_index = lines.index(selected_line) #
                
                app.current_active_line = selected_line
                app.current_active_line_index = selected_index
                app.entry.setText(selected_line)
                app.entry.setCursorPosition(0)
                print(f"Random line from active file: {selected_line}, Index: {selected_index}") #
            else:
                print(f"{os.path.basename(current_file_path)} est√° vac√≠o.")
                app.entry.clear()
                app.current_active_line = None
                app.current_active_line_index = None 
        else:
            print(f"{os.path.basename(current_file_path)} no existe.")
            app.entry.clear()
            app.current_active_line = None
            app.current_active_line_index = None
    except Exception as e:
        print(f"Error en show_random_line_from_current_file: {e}")
        app.entry.clear()

def show_previous_current_file_line(app, event=None):
    """Muestra la l√≠nea previa en el archivo activo, con comportamiento circular y contextual."""
    try:
        current_file_path = app.current_file_path # Usa el archivo activo
        print(f"Navegando a l√≠nea previa en: {current_file_path}")
        if not os.path.exists(current_file_path):
            print(f"{os.path.basename(current_file_path)} no existe.")
            app.entry.clear()
            return

        with open(current_file_path, 'r', encoding='utf-8') as f:
            lines = [line.rstrip('\n') for line in f.readlines() if line.strip()] 
        
        if not lines:
            print(f"{os.path.basename(current_file_path)} est√° vac√≠o.")
            app.entry.clear()
            app.current_active_line_index = None
            app.current_active_line = None
            return

        if not app.entry.text().strip() and app.last_inserted_index is not None:
            app.current_active_line_index = app.last_inserted_index 
            print(f"Entry vac√≠o, mostrando √∫ltima l√≠nea enviada, Index: {app.current_active_line_index}")
        elif app.current_active_line_index is None:
            app.current_active_line_index = len(lines) - 1
            print(f"Sin √≠ndice actual, empezando desde la √∫ltima l√≠nea, Index: {app.current_active_line_index}")
        else:
            app.current_active_line_index = (app.current_active_line_index - 1) % len(lines) 
            print(f"Navegando a l√≠nea previa, Index: {app.current_active_line_index}")

        app.current_active_line = lines[app.current_active_line_index]
        app.entry.setText(app.current_active_line)
        app.entry.setCursorPosition(0)
        print(f"Previous Line - {os.path.basename(current_file_path)}, Index: {app.current_active_line_index}, Line: {app.current_active_line}")
    except Exception as e:
        print(f"Error en show_previous_current_file_line: {e}") 
        app.entry.clear()

def show_next_current_file_line(app, event=None):
    """Muestra la l√≠nea siguiente en el archivo activo, con comportamiento circular."""
    try:
        current_file_path = app.current_file_path # Usa el archivo activo
        print(f"Navegando a l√≠nea siguiente en: {current_file_path}")
        if not os.path.exists(current_file_path):
            print(f"{os.path.basename(current_file_path)} no existe.")
            app.entry.clear()
            return

        with open(current_file_path, 'r', encoding='utf-8') as f: 
            lines = [line.rstrip('\n') for line in f.readlines() if line.strip()]
        
        if not lines:
            print(f"{os.path.basename(current_file_path)} est√° vac√≠o.")
            app.entry.clear()
            app.current_active_line_index = None
            app.current_active_line = None
            return 

        if not app.entry.text().strip() and app.last_inserted_index is not None:
            app.current_active_line_index = (app.last_inserted_index + 1) % len(lines)
            print(f"Entry vac√≠o, mostrando l√≠nea siguiente a la √∫ltima enviada, Index: {app.current_active_line_index}")
        elif app.current_active_line_index is None:
            app.current_active_line_index = 0 
            print(f"Sin √≠ndice actual, empezando desde la primera l√≠nea, Index: {app.current_active_line_index}")
        else:
            app.current_active_line_index = (app.current_active_line_index + 1) % len(lines)
            print(f"Navegando a l√≠nea siguiente, Index: {app.current_active_line_index}")

        app.current_active_line = lines[app.current_active_line_index]
        app.entry.setText(app.current_active_line)
        app.entry.setCursorPosition(0)
        print(f"Next Line - {os.path.basename(current_file_path)}, Index: {app.current_active_line_index}, Line: {app.current_active_line}")
    except Exception as e: 
        print(f"Error en show_next_current_file_line: {e}")
        app.entry.clear()

# --- files.py ---
import os
import random
import re
import datetime # Aseg√∫rate de que datetime est√© importado si se usa en otras partes que afectan a void_line
import sys # Necesario para determinar app_path en setup_file_handling si se ejecuta como congelado

def setup_file_handling(app):
    """Inicializa el manejo de 0.txt en el directorio void y el archivo activo."""
    if not os.path.exists(app.void_dir):
        os.makedirs(app.void_dir)
    # Asegura que 0.txt exista al inicio
    if not os.path.exists(app.void_file_path):
        with open(app.void_file_path, 'w', encoding='utf-8') as void_file:
            void_file.write('')
    
    # Inicializa el archivo activo al 0.txt
    app.current_file_path = app.void_file_path 
    app.current_active_line = None
    app.current_active_line_index = None
    app.last_inserted_index = None 

def void_line(app, event=None):
    """Procesa la l√≠nea ingresada, formate√°ndola y guard√°ndola en el archivo activo,
       o ejecutando un comando de archivo (cambiar o mover bloques/l√≠neas)."""
    try:
        line = app.entry.text().strip()
        app.entry.clear()
        app.entry.setFocus()

        if not line:
            app.current_active_line_index = None 
            app.current_active_line = None
            return # No hacer nada si la l√≠nea est√° vac√≠a

        # --- Nuevo: Verificar si se intenta a√±adir un punto consecutivo ---
        last_line_in_file = None
        if os.path.exists(app.current_file_path):
            with open(app.current_file_path, 'r', encoding='utf-8') as f:
                # Leer l√≠neas en reversa para encontrar la √∫ltima l√≠nea no vac√≠a eficientemente
                # y evitar cargar todo el archivo en memoria si es muy grande.
                lines = f.readlines()
                for l in reversed(lines):
                    stripped_l = l.strip()
                    if stripped_l: # Encontrar la √∫ltima l√≠nea que no est√© vac√≠a
                        last_line_in_file = stripped_l
                        break

        # Si la entrada es un solo punto y la √∫ltima l√≠nea en el archivo tambi√©n es un solo punto,
        # entonces no se procesa esta entrada.
        if line == '.' and last_line_in_file == '.':
            print("Se evit√≥ a√±adir puntos √∫nicos consecutivos.")
            app.current_active_line_index = None
            app.current_active_line = None
            app.last_inserted_index = None
            return # No procesar esta entrada

        # --- 1. Manejo de comandos de cambio de archivo (//) ---
        if line.startswith("//"):
            target_filename = line[2:].strip()
            if not target_filename: # Si solo se escribe "//", ir a 0.txt
                target_filename = "0" 
            
            # Normalizar el nombre del archivo
            if not target_filename.lower().endswith(".txt"):
                target_filename += ".txt"
            
            new_file_full_path = os.path.join(app.void_dir, target_filename)

            if new_file_full_path != app.current_file_path:
                # Cambiar el archivo activo
                app.current_file_path = new_file_full_path
                # Crear el archivo si no existe
                if not os.path.exists(app.current_file_path):
                    with open(app.current_file_path, 'w', encoding='utf-8') as f:
                        f.write('')
                    print(f"Archivo creado: {os.path.basename(app.current_file_path)}")
                
                print(f"Cambiado al archivo: {os.path.basename(app.current_file_path)}")
                # Resetear el estado de navegaci√≥n para el nuevo archivo
                app.current_active_line = None
                app.current_active_line_index = None
                app.last_inserted_index = None
            else:
                print(f"Ya est√°s en el archivo: {os.path.basename(app.current_file_path)}")
            return # Finalizar procesamiento de esta l√≠nea

        # --- 2. Manejo de "Mover una Sola L√≠nea" (Ej: "Mi contenido /nombre_archivo") ---
        # Busca el patr√≥n de texto seguido de un espacio y el comando /filename al final de la l√≠nea.
        match_single_line_move = re.search(r'(.*)\s+/([a-zA-Z0-9_.-]+\.txt|[a-zA-Z0-9_.-]+)$', line)
        
        if match_single_line_move:
            content_to_move = match_single_line_move.group(1).strip()
            target_filename_raw = match_single_line_move.group(2).strip()

            if not target_filename_raw:
                print("Comando de mover l√≠nea incompleto.")
                return

            target_filename = target_filename_raw
            if not target_filename.lower().endswith(".txt"):
                target_filename += ".txt"
            target_file_path = os.path.join(app.void_dir, target_filename)

            # Asegurar que el archivo de destino exista
            if not os.path.exists(target_file_path):
                with open(target_file_path, 'w', encoding='utf-8') as f:
                    f.write('')
            
            # Mover el contenido al archivo de destino
            with open(target_file_path, 'a', encoding='utf-8') as target_f:
                target_f.write(content_to_move + '\n')
            print(f"L√≠nea '{content_to_move}' movida a {os.path.basename(target_file_path)}")

            # Ahora, eliminar la l√≠nea del archivo de origen si fue una edici√≥n/reemplazo
            if app.current_active_line_index is not None:
                all_file_lines = []
                if os.path.exists(app.current_file_path):
                    with open(app.current_file_path, 'r', encoding='utf-8') as f:
                        all_file_lines = f.readlines()
                
                # Eliminar la l√≠nea original que conten√≠a el comando
                if app.current_active_line_index < len(all_file_lines):
                    del all_file_lines[app.current_active_line_index]
                
                # Reescribir el archivo de origen
                with open(app.current_file_path, 'w', encoding='utf-8') as current_f:
                    current_f.writelines(all_file_lines)
                    current_f.flush()
                    os.fsync(current_f.fileno())
                
                # Si el archivo de origen queda vac√≠o despu√©s de eliminar la l√≠nea (y no es 0.txt), eliminarlo
                if not all_file_lines and app.current_file_path != app.void_file_path:
                    os.remove(app.current_file_path)
                    print(f"Archivo {os.path.basename(app.current_file_path)} vac√≠o y eliminado.")
                    app.current_file_path = app.void_file_path # Volver a 0.txt
                    print(f"Regresando al archivo: {os.path.basename(app.current_file_path)}")

            app.current_active_line = None
            app.current_active_line_index = None
            app.last_inserted_index = None
            return # Finalizar procesamiento de esta l√≠nea

        # --- 3. Manejo de "Mover Bloque Completo" (Ej: "/nombre_archivo" en una l√≠nea sola) ---
        if line.startswith("/"): # Solo si no fue manejado por el caso anterior
            target_filename_raw = line[1:].strip()
            if not target_filename_raw:
                print("Comando de mover bloque incompleto. Escribe /nombre_archivo.txt")
                return
            
            target_filename = target_filename_raw
            if not target_filename.lower().endswith(".txt"):
                target_filename += ".txt"
            target_file_path = os.path.join(app.void_dir, target_filename)

            all_file_lines = []
            if os.path.exists(app.current_file_path):
                with open(app.current_file_path, 'r', encoding='utf-8') as f:
                    all_file_lines = f.readlines()
            
            # Determinar el √≠ndice donde el comando fue/ser√° insertado
            command_insert_index = len(all_file_lines) # Por defecto, al final
            if app.current_active_line_index is not None:
                command_insert_index = app.current_active_line_index
            
            # Encontrar el inicio del bloque a mover (√∫ltimo punto antes de command_insert_index)
            block_start_index = 0
            for i in range(command_insert_index - 1, -1, -1):
                if all_file_lines[i].strip() == '.':
                    block_start_index = i
                    break
            
            # Extraer el bloque a mover
            block_to_move = all_file_lines[block_start_index : command_insert_index]
            
            # >>> CORRECCI√ìN: NUNCA insertar el comando como texto normal si no hay bloque <<<
            if not block_to_move:
                print(f"No se encontr√≥ un bloque para mover con el comando '{line}'. No se realiz√≥ ninguna acci√≥n en el archivo.")
                app.current_active_line = None
                app.current_active_line_index = None
                app.last_inserted_index = None
                return # Simplemente retornar, sin modificar el archivo de origen.

            # Asegurar que el archivo de destino exista
            if not os.path.exists(target_file_path):
                with open(target_file_path, 'w', encoding='utf-8') as f:
                    f.write('')
            
            # >>> NUEVA L√ìGICA: A√±adir punto al inicio del bloque en el archivo de destino <<<
            with open(target_file_path, 'r+', encoding='utf-8') as target_f: # Abrir para leer y escribir
                target_content = target_f.read()
                # Si el archivo est√° vac√≠o o no termina con un punto, a√±adir un punto antes del bloque
                if not target_content.strip() or target_content.strip().endswith('.'):
                    # Si termina con un punto, o est√° vac√≠o, a√±adir el bloque directamente
                    # (el punto inicial del bloque se a√±adir√° al escribir)
                    pass 
                else: # Si termina sin punto, pero no est√° vac√≠o, asegurar que haya un punto antes de a√±adir el nuevo bloque
                    target_f.write('.\n') # A√±adir un punto para separar el bloque anterior del nuevo

                # Mover el puntero al final del archivo para a√±adir el nuevo contenido
                target_f.seek(0, os.SEEK_END)
                
                # El bloque debe empezar con un punto en el destino
                final_block_to_write = []
                if not block_to_move[0].strip() == '.': # Si el bloque no empieza ya con un punto, a√±adir uno
                    final_block_to_write.append('.\n')
                final_block_to_write.extend(block_to_move)

                target_f.writelines(final_block_to_write)
            
            # --- CORRECCI√ìN: El comando NO se incluye en new_source_lines aqu√≠. ---
            # Construir las nuevas l√≠neas del archivo de origen:
            # L√≠neas antes del bloque + l√≠neas despu√©s de la l√≠nea del comando (excluyendo el comando)
            new_source_lines = all_file_lines[:block_start_index] + all_file_lines[command_insert_index + 1:]

            # >>> NUEVA L√ìGICA: Reinsertar punto en el archivo de origen si es necesario <<<
            # Esto ocurre si hab√≠a contenido antes Y despu√©s del bloque extra√≠do,
            # y la l√≠nea justo antes del bloque extra√≠do NO era ya un punto.
            if block_start_index > 0 and command_insert_index + 1 <= len(all_file_lines): # <= para incluir el caso de que command_insert_index sea el √∫ltimo
                # Verificar si la l√≠nea que estaba justo antes del inicio del bloque movido (all_file_lines[block_start_index - 1])
                # era un punto. Si no lo era, y el bloque que se movi√≥ S√ç comenz√≥ con un punto
                # (o simplemente hay una brecha entre dos secciones que ahora necesitan un punto)
                # entonces reinsertamos un punto en el origen.
                
                # Si la l√≠nea justo ANTES de la brecha no era un punto
                # Y hay contenido ANTES y DESPU√âS de la brecha.
                if all_file_lines[block_start_index - 1].strip() != '.':
                    # Insertar un punto en la posici√≥n donde sol√≠a comenzar el bloque movido
                    new_source_lines.insert(block_start_index, '.\n')


            # Reescribir el archivo de origen
            with open(app.current_file_path, 'w', encoding='utf-8') as current_f:
                current_f.writelines(new_source_lines)
                current_f.flush()
                os.fsync(current_f.fileno())

            print(f"Bloque movido de {os.path.basename(app.current_file_path)} a {os.path.basename(target_file_path)}")
            
            # Si el archivo de origen queda completamente vac√≠o (incluyendo la ausencia del comando), y no es 0.txt, eliminarlo.
            if not new_source_lines and app.current_file_path != app.void_file_path:
                os.remove(app.current_file_path)
                print(f"Archivo {os.path.basename(app.current_file_path)} vac√≠o y eliminado.")
                app.current_file_path = app.void_file_path # Volver a 0.txt
                print(f"Regresando al archivo: {os.path.basename(app.current_file_path)}")

            app.current_active_line = None
            app.current_active_line_index = None
            app.last_inserted_index = None
            return # Finalizar procesamiento de esta l√≠nea

        # --- 4. Manejo de texto normal (si no es un comando) ---
        # MODIFICACI√ìN APLICADA AQU√ç (Opci√≥n 1)
        if line == '.': # <-- Si la l√≠nea es SOLO un punto, la tratamos de forma especial
            formatted_lines = ['.'] # La lista de l√≠neas formateadas es solo un punto.
        else: 
            protected = line.replace("...", "<ELLIPSIS>")
            raw_sentences = re.split(r'\.(?=\s|$)', protected) 
            formatted_lines = []
            for raw in raw_sentences:
                s = raw.strip()
                if not s:
                    continue
                s = s.replace("<ELLIPSIS>", "...") 
                s = s[0].upper() + s[1:] if s else s
                if not s.endswith('.') and not s.endswith('...'):
                    s += '.'
                formatted_lines.append(s) 
        formatted_text = '\n'.join(formatted_lines)
        # --- FIN FORMATO ---

        # Leer l√≠neas del archivo activo
        with open(app.current_file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines() 

        if hasattr(app, 'current_active_line_index') and app.current_active_line_index is not None:
            # Si estamos editando una l√≠nea existente (navegaci√≥n previa/siguiente)
            if app.current_active_line_index < len(lines): 
                lines[app.current_active_line_index] = formatted_text + '\n'
                app.last_inserted_index = app.current_active_line_index
            app.current_active_line_index = None 
            app.current_active_line = None
        else:
            # Si estamos a√±adiendo una nueva l√≠nea
            insert_index = (app.last_inserted_index + 1) if hasattr(app, 'last_inserted_index') and app.last_inserted_index is not None else len(lines)
            
            # Asegurarse de que el √≠ndice de inserci√≥n no exceda el n√∫mero de l√≠neas existentes + 1
            if insert_index > len(lines):
                insert_index = len(lines)

            lines[insert_index:insert_index] = [line_to_add + '\n' for line_to_add in formatted_lines]
            app.last_inserted_index = insert_index + len(formatted_lines) - 1 
            app.current_active_line_index = None
            app.current_active_line = None

        # Escribir todas las l√≠neas de vuelta al archivo activo
        with open(app.current_file_path, 'w', encoding='utf-8') as f:
            f.writelines(lines)
            f.flush()
            os.fsync(f.fileno())
        
        print(f"L√≠neas insertadas/modificadas en {os.path.basename(app.current_file_path)}.") 

    except Exception as e:
        print(f"Error en void_line: {e}") 
        app.entry.clear()
        app.entry.setFocus()


# --- new_interface.py ---
import os
import sys
import numpy as np
from PyQt6.QtWidgets import QApplication, QMainWindow, QLineEdit, QLabel, QWidget
from PyQt6.QtGui import QColor, QPainter, QFont, QCursor, QPen, QPixmap, QImage
from PyQt6.QtCore import Qt, QTimer
from files import setup_file_handling, void_line
from controls import setup_controls, show_random_line_from_current_file, show_previous_current_file_line, show_next_current_file_line 
from noise_controls import NoiseController

class CustomLineEdit(QLineEdit):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent

    def keyPressEvent(self, event):
        key = event.key()
        modifiers = event.modifiers()
        
        if key == Qt.Key.Key_0:
            # Si no hay una barra en el texto actual del QLineEdit, activa el shuffle
            if '/' not in self.text(): 
                print("Tecla 0 detectada en QLineEdit SIN barra, ejecutando show_random_line_from_current_file") 
                self.parent.last_inserted_index = None 
                show_random_line_from_current_file(self.parent, event)
                event.accept() # Consumir el evento para que '0' no se escriba
            else:
                # Si hay una barra, permite que '0' se escriba normalmente
                super().keyPressEvent(event) 
        elif (key == Qt.Key.Key_Up or key == Qt.Key.Key_Down) and modifiers == Qt.KeyboardModifier.ControlModifier:
            self.parent.keyPressEvent(event)
        else:
            super().keyPressEvent(event)

class CircleBackground(QWidget):
    def __init__(self, parent=None, center_x=0, center_y=0, radius=0):
        super().__init__(parent)
        self.center_x = center_x 
        self.center_y = center_y
        self.radius = radius
        self.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        pen = QPen(QColor("white"), 10)
        painter.setPen(pen)
        painter.setBrush(Qt.BrushStyle.NoBrush)
        painter.drawEllipse(
            self.center_x - self.radius, 
            self.center_y - self.radius,
            self.radius * 2,
            self.radius * 2
        )

    def resizeEvent(self, event):
        self.resize(self.parent().size())

class NoiseOverlay(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents) 
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.noise_pixmap = None
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.generate_noise)
        self.timer.start(50)

    def generate_noise(self):
        block_size = 1
        w, h = self.width(), self.height()
        h_blocks, w_blocks = h // block_size, w // block_size
        noise_gray = np.random.randint(0, 256, (h_blocks, w_blocks), dtype=np.uint8) 
        image = QImage(noise_gray.data, w_blocks, h_blocks, w_blocks, QImage.Format.Format_Grayscale8)
        image = image.scaled(w, h, Qt.AspectRatioMode.IgnoreAspectRatio, Qt.TransformationMode.FastTransformation)
        self.noise_pixmap = QPixmap.fromImage(image)
        self.update()

    def paintEvent(self, event):
        if self.noise_pixmap:
            painter = QPainter(self)
            painter.setOpacity(0.09)  # <- M√°s visible 
            painter.drawPixmap(0, 0, self.noise_pixmap)

class FullscreenCircleApp(QMainWindow):
    def __init__(self, read_dir=None, void_dir=None):
        super().__init__()
        self.opacity = 1.0
        self.read_dir = read_dir or os.path.dirname(os.path.abspath(__file__))
        self.void_dir = void_dir or os.path.join(self.read_dir, 'void')
        self.setWindowTitle("Voider")
        self.setWindowFlag(Qt.WindowType.FramelessWindowHint)
        self.setCursor(QCursor(Qt.CursorShape.BlankCursor))
        self.setStyleSheet("background-color: black;")

        self.entry = CustomLineEdit(self) 
        self.entry.setFont(QFont("Consolas", 11))
        self.entry.setStyleSheet("""
            QLineEdit {
                background-color: black;
                color: white; 
                border: none;
                qproperty-alignment: AlignCenter;
                selection-background-color: white;
                selection-color: black;
            }
        """) 
        self.entry.setFocus()
        self.entry.returnPressed.connect(lambda: void_line(self)) 

        self.loading = QLabel("Loading potentiality", self)
        self.loading.setFont(QFont("Consolas", 11))
        self.loading.setStyleSheet("color: white; background-color: black;")
        self.loading.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.loading.resize(300, 100)
        self.loading.hide()

        self.noise_controller = NoiseController(
            block_size=1024, volume=0.3, noise_type='brown', 
            bitcrush={'bit_depth': 10, 'sample_rate_factor': 0.7},
            lfo_min_freq=0.03, lfo_max_freq=0.1, glitch_prob=0.005, cutoff_freq=2500
        )

        self.setup_voider_logic()
        self.init_ui()

    def setup_voider_logic(self):
        os.makedirs(self.void_dir, exist_ok=True)
        self.void_file_path = os.path.join(self.void_dir, '0.txt') # Ruta a 0.txt (constante)
        print(f"void_file_path inicializado (0.txt): {self.void_file_path}")
        
        # Nueva variable para el archivo actualmente activo
        self.current_file_path = self.void_file_path # Inicialmente, el archivo activo es 0.txt

        self.current_active_line = None # Renombrado de current_zero_line
        self.current_active_line_index = None # Renombrado de current_zero_line_index
        self.last_inserted_index = None 
        setup_file_handling(self)
        setup_controls(self)

    def init_ui(self):
        print("Initializing UI")
        self.showFullScreen()
        screen = self.screen().availableGeometry()
        self.center_x = screen.width() // 2
        self.center_y = screen.height() // 2
        self.radius = min(screen.width(), screen.height()) // 2 - 35 
        entry_width = self.radius * 2 - 40
        self.entry.setFixedWidth(entry_width)
        self.entry.move(self.center_x - entry_width // 2,
                        self.center_y - self.entry.height() // 2)
        self.loading.move(self.center_x - 150, self.center_y - 50)
        self.loading.show()
        QTimer.singleShot(1500, self.loading.deleteLater) 

        self.circle_background = CircleBackground(self, self.center_x, self.center_y, self.radius)
        self.circle_background.resize(self.size())
        self.circle_background.show()

        self.noise_overlay = NoiseOverlay(self)
        self.noise_overlay.resize(self.size())
        self.noise_overlay.show()
        self.noise_overlay.raise_() # <- Esto lo pone sobre todo

    def resizeEvent(self, event):
        super().resizeEvent(event)
        if hasattr(self, 'noise_overlay'):
            self.noise_overlay.resize(self.size()) 
        if hasattr(self, 'circle_background'):
            self.circle_background.resize(self.size())

    def keyPressEvent(self, event):
        key = event.key()
        modifiers = event.modifiers()
        print(f"Tecla en ventana: {key}, Modificadores: {modifiers}")

        if key == Qt.Key.Key_Escape:
            self.noise_controller.stop()
            self.close() 
        elif key == Qt.Key.Key_Up and modifiers == Qt.KeyboardModifier.ControlModifier:
            self.increase_opacity()
        elif key == Qt.Key.Key_Down and modifiers == Qt.KeyboardModifier.ControlModifier:
            self.decrease_opacity()
        elif key == Qt.Key.Key_Up:
            show_previous_current_file_line(self) # Actualizado para el archivo activo
        elif key == Qt.Key.Key_Down:
            show_next_current_file_line(self) # Actualizado para el archivo activo

    def increase_opacity(self):
        self.opacity = min(1.0, self.opacity + 0.1)
        self.setWindowOpacity(self.opacity)

    def decrease_opacity(self):
        self.opacity = max(0.0, self.opacity - 0.1)
        self.setWindowOpacity(self.opacity)

if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = FullscreenCircleApp()
    window.show()
    sys.exit(app.exec())

# --- noise_controls.py ---
# --- noise_controls.py ---
import numpy as np
import sounddevice as sd
from PyQt6.QtCore import QTimer

class NoiseController:
    def __init__(self, sample_rate=44100, block_size=1024, volume=0.01, noise_type='brown',
                 bitcrush={'bit_depth': 8, 'sample_rate_factor': 0.6},
                 lfo_min_freq=0.01, lfo_max_freq=0.03, glitch_prob=0.001, cutoff_freq=300):
        self.sample_rate = sample_rate
        self.block_size = block_size
        self.volume = volume
        self.noise_type = noise_type
        self.bitcrush = bitcrush
        self.lfo_min_freq = lfo_min_freq
        self.lfo_max_freq = lfo_max_freq
        self.glitch_prob = glitch_prob
        self.cutoff_freq = cutoff_freq
        self.stream = None
        self.timer = None
        self.lfo_state = 0

        try:
            self.stream = sd.OutputStream(
                samplerate=sample_rate,
                blocksize=block_size,
                channels=2,
                callback=self.audio_callback
            )
            self.stream.start()
            self.start_lfo_generator()
            print(f"NoiseController: {self.noise_type.capitalize()} subtle meditative noise started.")
        except Exception as e:
            print(f"NoiseController: Error initializing audio: {str(e)}")

    def lowpass_filter(self, data, cutoff, alpha=0.1):
        """
        Filtro pasa bajos simple usando un filtro de media m√≥vil exponencial.
        `alpha` controla la suavidad (m√°s bajo = m√°s suave).
        """
        filtered = np.zeros_like(data)
        filtered[0] = data[0]
        for i in range(1, len(data)):
            filtered[i] = alpha * data[i] + (1 - alpha) * filtered[i - 1]
        return filtered

    def apply_bitcrush(self, noise, bit_depth=16, sample_rate_factor=1.0):
        original_length = len(noise)
        if sample_rate_factor < 1.0:
            new_length = int(original_length * sample_rate_factor)
            new_length = max(1, new_length)
            indices = np.linspace(0, original_length - 1, new_length).astype(int)
            noise = noise[indices]
            noise = np.tile(noise, (original_length // len(noise) + 1))[:original_length]
        if bit_depth < 16:
            max_val = 2 ** (bit_depth - 1) - 1
            noise = np.round(noise / 32767 * max_val) / max_val * 32767
        return noise.astype(np.int16)

    def generate_variable_lfo(self, t, min_freq, max_freq):
        n_points = 4
        rand_freqs = np.random.uniform(min_freq, max_freq, n_points)
        rand_phases = np.random.uniform(0, 2 * np.pi, n_points)
        key_times = np.linspace(0, self.block_size / self.sample_rate, n_points)
        freqs = np.interp(t, key_times, rand_freqs)
        phases = np.interp(t, key_times, rand_phases)
        return 0.97 + 0.03 * np.sin(2 * np.pi * freqs * t + phases)

    def audio_callback(self, outdata, frames, time, status):
        if status:
            print(f"Audio callback status: {status}")
        if frames != self.block_size:
            return

        if self.noise_type == 'brown':
            white = np.random.uniform(-1, 1, frames)
            brown = np.cumsum(white)
            noise = brown / np.max(np.abs(brown)) * 0.8
        elif self.noise_type == 'white':
            noise = np.random.uniform(-1, 1, frames)
        elif self.noise_type == 'pink':
            white = np.random.uniform(-1, 1, frames)
            pink = np.cumsum(white) / np.arange(1, frames + 1) ** 0.5
            noise = pink / np.max(np.abs(pink)) * 0.8
        else:
            noise = np.zeros(frames)

        noise = self.lowpass_filter(noise, cutoff=self.cutoff_freq)

        t = np.linspace(self.lfo_state, self.lfo_state + frames / self.sample_rate, frames)
        self.lfo_state += frames / self.sample_rate
        noise *= self.generate_variable_lfo(t, self.lfo_min_freq, self.lfo_max_freq)

        if np.random.rand() < 0.25:  # reducir cantidad de glitches
            glitch_mask = np.random.random(frames) < self.glitch_prob
            noise[glitch_mask] *= np.random.uniform(0.9, 1.1, glitch_mask.sum())

        if self.bitcrush:
            bit_depth = self.bitcrush.get('bit_depth', 8)
            sample_rate_factor = self.bitcrush.get('sample_rate_factor', 0.6)
            noise = (noise * 32767).astype(np.float32)
            noise = self.apply_bitcrush(noise, bit_depth, sample_rate_factor)

        noise = noise / np.max(np.abs(noise)) * 0.1 * self.volume
        stereo_noise = np.repeat(noise[:, np.newaxis], 2, axis=1)
        outdata[:] = stereo_noise

    def start_lfo_generator(self):
        self.timer = QTimer()
        self.timer.timeout.connect(lambda: None)
        self.timer.start(100)

    def stop(self):
        if self.stream:
            self.stream.stop()
            self.stream.close()
        if self.timer:
            self.timer.stop()
        print("NoiseController: Stopped")

    def set_volume(self, volume):
        self.volume = max(0.0, min(1.0, volume))
        print(f"NoiseController: Volume set to {self.volume:.2f}")

    def set_noise_type(self, noise_type):
        self.noise_type = noise_type
        print(f"NoiseController: Noise type set to {self.noise_type}")

    def set_bitcrush(self, bitcrush):
        self.bitcrush = bitcrush
        print(f"NoiseController: Bitcrush set to {self.bitcrush}")

    def set_lfo_freq(self, min_freq, max_freq):
        self.lfo_min_freq = min_freq
        self.lfo_max_freq = max_freq
        print(f"NoiseController: LFO freq range set to {min_freq:.2f}-{max_freq:.2f} Hz")

    def set_glitch_prob(self, prob):
        self.glitch_prob = max(0.0, min(0.1, prob))
        print(f"NoiseController: Glitch probability set to {self.glitch_prob:.4f}")

    def set_cutoff_freq(self, cutoff):
        self.cutoff_freq = max(50, min(8000, cutoff))
        print(f"NoiseController: Cutoff frequency set to {self.cutoff_freq} Hz")


# --- tools.py ---
# --- tools.py ---
def clean_text(text):
    return text  # Devolver texto sin cambios

def close_program(app, event=None):
    app.close()

def show_cursor(app, event=None):
    app.entry.setCursorVisible(True)

# --- voider.py ---
# --- voider.py ---
import os
import sys
from PyQt6.QtWidgets import QApplication
from new_interface import FullscreenCircleApp

if __name__ == "__main__":
    try:
        if getattr(sys, 'frozen', False):
            app_path = os.path.dirname(sys.executable)
        else:
            app_path = os.path.dirname(os.path.abspath(__file__))  # V01DER directory
        read_dir = os.path.dirname(app_path)  # Z:\programming\Voider\V2
        void_dir = os.path.join(app_path, 'void')  # Z:\programming\Voider\V2\V01DER\void
        print(f"Working directory: {os.getcwd()}")
        print(f"App path: {app_path}")
        print(f"Void dir: {void_dir}")
        if not os.path.exists(void_dir):
            print(f"Creating: {void_dir}")
            try:
                os.makedirs(void_dir)
            except Exception as e:
                print(f"Error creating void folder: {e}")
        else:
            print(f"Void folder exists: {void_dir}")
        app = QApplication(sys.argv)
        window = FullscreenCircleApp(read_dir=read_dir, void_dir=void_dir)
        window.show()
        print("Window shown")
        sys.exit(app.exec())
    except Exception as e:
        print(f"Error: {e}")
        input("Press Enter to exit...")

# --- __init__.py ---
